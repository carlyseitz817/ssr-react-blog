{"version":3,"file":"slate-react.es.js","sources":["../src/constants/event-handlers.js","../src/constants/transfer-types.js","../src/utils/find-dom-node.js","../src/utils/remove-all-ranges.js","../src/utils/offset-key.js","../src/utils/find-point.js","../src/utils/clone-fragment.js","../src/utils/find-node.js","../src/utils/find-dom-point.js","../src/utils/find-range.js","../src/utils/get-event-range.js","../src/utils/get-event-transfer.js","../src/utils/set-event-transfer.js","../src/plugins/after.js","../src/plugins/before.js","../src/plugins/dom.js","../src/components/leaf.js","../src/components/text.js","../src/components/void.js","../src/utils/get-children-decorations.js","../src/components/node.js","../src/utils/find-dom-range.js","../src/utils/scroll-to-selection.js","../src/components/content.js","../src/plugins/react.js","../src/components/editor.js","../src/index.js"],"sourcesContent":["/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst EVENT_HANDLERS = [\n  'onBeforeInput',\n  'onBlur',\n  'onClick',\n  'onContextMenu',\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCopy',\n  'onCut',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onInput',\n  'onFocus',\n  'onKeyDown',\n  'onKeyUp',\n  'onMouseDown',\n  'onMouseUp',\n  'onPaste',\n  'onSelect',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS\n","/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nconst TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain',\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default TRANSFER_TYPES\n","import { Node } from 'slate'\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key, win = window) {\n  if (Node.isNode(key)) {\n    key = key.key\n  }\n\n  const el = win.document.querySelector(`[data-key=\"${key}\"]`)\n\n  if (!el) {\n    throw new Error(\n      `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n    )\n  }\n\n  return el\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMNode\n","/**\n * COMPAT: if we are in <= IE11 and the selection contains\n * tables, `removeAllRanges()` will throw\n * \"unable to complete the operation due to error 800a025e\"\n *\n * @param {Selection} selection document selection\n */\n\nfunction removeAllRanges(selection) {\n  const doc = window.document\n\n  if (doc && doc.body.createTextRange) {\n    // All IE but Edge\n    const range = doc.body.createTextRange()\n    range.collapse()\n    range.select()\n  } else {\n    selection.removeAllRanges()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  const matches = PARSER.exec(string)\n\n  if (!matches) {\n    throw new Error(`Invalid offset key string \"${string}\".`)\n  }\n\n  const [original, key, index] = matches // eslint-disable-line no-unused-vars\n  return {\n    key,\n    index: parseInt(index, 10),\n  }\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return `${object.key}:${object.index}`\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  parse,\n  stringify,\n}\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\nimport OffsetKey from './offset-key'\n\n/**\n * Constants.\n *\n * @type {String}\n */\n\nexport const ZERO_WIDTH_ATTRIBUTE = 'data-slate-zero-width'\nexport const ZERO_WIDTH_SELECTOR = `[${ZERO_WIDTH_ATTRIBUTE}]`\nconst OFFSET_KEY_ATTRIBUTE = 'data-offset-key'\nconst RANGE_SELECTOR = `[${OFFSET_KEY_ATTRIBUTE}]`\nconst TEXT_SELECTOR = `[data-key]`\nconst VOID_SELECTOR = '[data-slate-void]'\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.'\n  )\n\n  const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n    nativeNode,\n    nativeOffset\n  )\n\n  const window = getWindow(nativeNode)\n  const { parentNode } = nearestNode\n  let rangeNode = parentNode.closest(RANGE_SELECTOR)\n  let offset\n  let node\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    const range = window.document.createRange()\n    const textNode = rangeNode.closest(TEXT_SELECTOR)\n    range.setStart(textNode, 0)\n    range.setEnd(nearestNode, nearestOffset)\n    node = textNode\n    offset = range.toString().length\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    const voidNode = parentNode.closest(VOID_SELECTOR)\n    if (!voidNode) return null\n    rangeNode = voidNode.querySelector(RANGE_SELECTOR)\n    if (!rangeNode) return null\n    node = rangeNode\n    offset = node.textContent.length\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (\n    offset == node.textContent.length &&\n    parentNode.hasAttribute(ZERO_WIDTH_ATTRIBUTE)\n  ) {\n    offset--\n  }\n\n  // Get the string value of the offset key attribute.\n  const offsetKey = rangeNode.getAttribute(OFFSET_KEY_ATTRIBUTE)\n  if (!offsetKey) return null\n\n  const { key } = OffsetKey.parse(offsetKey)\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  const { value } = editor\n  if (!value.document.hasDescendant(key)) return null\n\n  const point = value.document.createPoint({ key, offset })\n  return point\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType == 1 && node.childNodes.length) {\n    const isLast = offset == node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType == 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType == 8 ||\n    (child.nodeType == 1 && child.childNodes.length == 0) ||\n    (child.nodeType == 1 && child.getAttribute('contenteditable') == 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction == 'forward') i++\n    if (direction == 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPoint\n","import Base64 from 'slate-base64-serializer'\nimport Plain from 'slate-plain-serializer'\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport findDOMNode from './find-dom-node'\nimport getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport removeAllRanges from './remove-all-ranges'\nimport { IS_IE } from 'slate-dev-environment'\nimport { Value } from 'slate'\nimport { ZERO_WIDTH_SELECTOR, ZERO_WIDTH_ATTRIBUTE } from './find-point'\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor, callback = () => undefined) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.'\n  )\n\n  const window = getWindow(event.target)\n  const native = window.getSelection()\n  const { value } = editor\n  const { document, fragment, selection } = value\n  const { start, end } = selection\n  const startVoid = document.getClosestVoid(start.key, editor)\n  const endVoid = document.getClosestVoid(end.key, editor)\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const encoded = Base64.serializeNode(fragment)\n  const range = native.getRangeAt(0)\n  let contents = range.cloneContents()\n  let attach = contents.childNodes[0]\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const r = range.cloneRange()\n    const node = findDOMNode(endVoid, window)\n    r.setEndAfter(node)\n    contents = r.cloneContents()\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  ;[].slice.call(contents.querySelectorAll(ZERO_WIDTH_SELECTOR)).forEach(zw => {\n    const isNewline = zw.getAttribute(ZERO_WIDTH_ATTRIBUTE) === 'n'\n    zw.textContent = isNewline ? '\\n' : ''\n  })\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType == 3) {\n    const span = window.document.createElement('span')\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  attach.setAttribute('data-slate-fragment', encoded)\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  const valFromSelection = Value.create({ document: fragment })\n  const plainText = Plain.serialize(valFromSelection)\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  const div = window.document.createElement('div')\n  div.appendChild(contents)\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault()\n    event.clipboardData.setData(TEXT, plainText)\n    event.clipboardData.setData(FRAGMENT, encoded)\n    event.clipboardData.setData(HTML, div.innerHTML)\n    callback()\n    return\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  const editorEl = event.target.closest('[data-slate-editor]')\n  div.setAttribute('contenteditable', true)\n  div.style.position = 'absolute'\n  div.style.left = '-9999px'\n  editorEl.appendChild(div)\n  native.selectAllChildren(div)\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(() => {\n    editorEl.removeChild(div)\n    removeAllRanges(native)\n    native.addRange(range)\n    callback()\n  })\n}\n\nexport default cloneFragment\n","import invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\nfunction findNode(element, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const closest = element.closest('[data-key]')\n  if (!closest) return null\n\n  const key = closest.getAttribute('data-key')\n  if (!key) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = document.getNode(key)\n  return node || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findNode\n","import findDOMNode from './find-dom-node'\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point, win = window) {\n  const el = findDOMNode(point.key, win)\n  let start = 0\n\n  // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n  const texts = Array.from(\n    el.querySelectorAll('[data-slate-content], [data-slate-zero-width]')\n  )\n\n  for (const text of texts) {\n    const node = text.childNodes[0]\n    const domLength = node.textContent.length\n    let slateLength = domLength\n\n    if (text.hasAttribute('data-slate-length')) {\n      slateLength = parseInt(text.getAttribute('data-slate-length'), 10)\n    }\n\n    const end = start + slateLength\n\n    if (point.offset <= end) {\n      const offset = Math.min(domLength, Math.max(0, point.offset - start))\n      return { node, offset }\n    }\n\n    start = end\n  }\n\n  return null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMPoint\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { IS_IE, IS_EDGE } from 'slate-dev-environment'\nimport { Value } from 'slate'\n\nimport findPoint from './find-point'\nimport findDOMPoint from './find-dom-point'\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction findRange(native, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const el = native.anchorNode || native.startContainer\n  if (!el) return null\n\n  const window = getWindow(el)\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (\n    native instanceof window.Range ||\n    (window.StaticRange && native instanceof window.StaticRange)\n  ) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset,\n    }\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n    isCollapsed,\n  } = native\n  const { value } = editor\n  const anchor = findPoint(anchorNode, anchorOffset, editor)\n  const focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor)\n  if (!anchor || !focus) return null\n\n  // COMPAT: ??? The Edge browser seems to have a case where if you select the\n  // last word of a span, it sets the endContainer to the containing span.\n  // `selection-is-backward` doesn't handle this case.\n  if (IS_IE || IS_EDGE) {\n    const domAnchor = findDOMPoint(anchor)\n    const domFocus = findDOMPoint(focus)\n\n    native = {\n      anchorNode: domAnchor.node,\n      anchorOffset: domAnchor.offset,\n      focusNode: domFocus.node,\n      focusOffset: domFocus.offset,\n    }\n  }\n\n  const { document } = value\n  const range = document.createRange({\n    anchor,\n    focus,\n  })\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findRange\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\nimport findNode from './find-node'\nimport findRange from './find-range'\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction getEventRange(event, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const { x, y, target } = event\n  if (x == null || y == null) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = findNode(target, editor)\n  if (!node) return null\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (editor.query('isVoid', node)) {\n    const rect = target.getBoundingClientRect()\n    const isPrevious =\n      node.object == 'inline'\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n    const text = node.getFirstText()\n    const range = document.createRange()\n\n    if (isPrevious) {\n      const previousText = document.getPreviousText(text.key)\n\n      if (previousText) {\n        return range.moveToEndOfNode(previousText)\n      }\n    }\n\n    const nextText = document.getNextText(text.key)\n    return nextText ? range.moveToStartOfNode(nextText) : null\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  const window = getWindow(target)\n  let native\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y)\n  } else if (window.document.caretPositionFromPoint) {\n    const position = window.document.caretPositionFromPoint(x, y)\n    native = window.document.createRange()\n    native.setStart(position.offsetNode, position.offset)\n    native.setEnd(position.offsetNode, position.offset)\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange()\n\n    try {\n      native.moveToPoint(x, y)\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  const range = findRange(native, editor)\n  if (!range) return null\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventRange\n","import Base64 from 'slate-base64-serializer'\nimport { IS_IE } from 'slate-dev-environment'\nimport TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n  let fragment = getType(transfer, FRAGMENT)\n  let node = getType(transfer, NODE)\n  const html = getType(transfer, HTML)\n  const rich = getType(transfer, RICH)\n  let text = getType(transfer, TEXT)\n  let files\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(' data-slate-fragment=\"')) {\n    const matches = FRAGMENT_MATCHER.exec(html)\n    const [full, encoded] = matches // eslint-disable-line no-unused-vars\n    if (encoded) fragment = encoded\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    const embeddedTypes = getEmbeddedTypes(text)\n\n    if (embeddedTypes[FRAGMENT]) fragment = embeddedTypes[FRAGMENT]\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE]\n    if (embeddedTypes[TEXT]) text = embeddedTypes[TEXT]\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment)\n  if (node) node = Base64.deserializeNode(node)\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items)\n        .map(item => (item.kind == 'file' ? item.getAsFile() : null))\n        .filter(exists => exists)\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  }\n\n  // Determine the type of the data.\n  const data = { files, fragment, html, node, rich, text }\n  data.type = getTransferType(data)\n  return data\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  const prefix = 'SLATE-DATA-EMBED::'\n\n  if (text.substring(0, prefix.length) != prefix) {\n    return { TEXT: text }\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length))\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.')\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment'\n  if (data.node) return 'node'\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html'\n  if (data.rich && data.text) return 'text'\n\n  if (data.files && data.files.length) return 'files'\n  if (data.html) return 'html'\n  if (data.text) return 'text'\n  return 'unknown'\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type == TEXT ? transfer.getData('Text') || null : null\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  const types = Array.from(transfer.types)\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer\n","import TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  const mime = TRANSFER_TYPES[type.toUpperCase()]\n\n  if (!mime) {\n    throw new Error(`Cannot set unknown transfer type \"${mime}\".`)\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n\n  try {\n    transfer.setData(mime, content)\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'))\n  } catch (err) {\n    const prefix = 'SLATE-DATA-EMBED::'\n    const text = transfer.getData(TEXT)\n    let obj = {}\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length))\n      } catch (e) {\n        throw new Error(\n          'Failed to parse Slate data from `DataTransfer` object.'\n        )\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT] = text\n    }\n\n    obj[mime] = content\n    const string = `${prefix}${JSON.stringify(obj)}`\n    transfer.setData(TEXT, string)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer\n","import Base64 from 'slate-base64-serializer'\nimport Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport { IS_IOS } from 'slate-dev-environment'\n\nimport cloneFragment from '../utils/clone-fragment'\nimport findDOMNode from '../utils/find-dom-node'\nimport findNode from '../utils/find-node'\nimport findPoint from '../utils/find-point'\nimport findRange from '../utils/find-range'\nimport getEventRange from '../utils/get-event-range'\nimport getEventTransfer from '../utils/get-event-transfer'\nimport setEventTransfer from '../utils/set-event-transfer'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after')\n\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin(options = {}) {\n  let isDraggingInternally = null\n  let isMouseDown = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const { value } = editor\n    const isSynthetic = !!event.nativeEvent\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    if (isSynthetic) {\n      event.preventDefault()\n      editor.insertText(event.data)\n      return next()\n    }\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n    const [targetRange] = event.getTargetRanges()\n    if (!targetRange) return next()\n\n    debug('onBeforeInput', { event })\n\n    event.preventDefault()\n\n    const { document, selection } = value\n    const range = findRange(targetRange, editor)\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward': {\n        editor.deleteAtRange(range)\n        break\n      }\n\n      case 'deleteWordBackward': {\n        editor.deleteWordBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteWordForward': {\n        editor.deleteWordForwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward': {\n        editor.deleteLineBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward': {\n        editor.deleteLineForwardAtRange(range)\n        break\n      }\n\n      case 'insertLineBreak':\n      case 'insertParagraph': {\n        const hasVoidParent = document.hasVoidParent(\n          selection.start.path,\n          editor\n        )\n\n        if (hasVoidParent) {\n          editor.moveToStartOfNextText()\n        } else {\n          editor.splitBlockAtRange(range)\n        }\n\n        break\n      }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        // COMPAT: `data` should have the text for the `insertText` input type\n        // and `dataTransfer` should have the text for the\n        // `insertReplacementText` input type, but Safari uses `insertText` for\n        // spell check replacements and sets `data` to `null`. (2018/08/09)\n        const text =\n          event.data == null\n            ? event.dataTransfer.getData('text/plain')\n            : event.data\n\n        if (text == null) break\n\n        editor.insertTextAtRange(range, text, selection.marks)\n\n        // If the text was successfully inserted, and the selection had marks\n        // on it, unset the selection's marks.\n        if (selection.marks && value.document != editor.value.document) {\n          editor.select({ marks: null })\n        }\n\n        break\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    debug('onBlur', { event })\n    editor.blur()\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next()\n\n    const { value } = editor\n    const { document } = value\n    const node = findNode(event.target, editor)\n    if (!node) return next()\n\n    debug('onClick', { event })\n\n    const ancestors = document.getAncestors(node.key)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node)\n    }\n\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    debug('onCopy', { event })\n    cloneFragment(event, editor)\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    debug('onCut', { event })\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, editor, () => {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      const { value } = editor\n      const { endBlock, endInline, selection } = value\n      const { isCollapsed } = selection\n      const isVoidBlock = endBlock && editor.isVoid(endBlock) && isCollapsed\n      const isVoidInline = endInline && editor.isVoid(endInline) && isCollapsed\n\n      if (isVoidBlock) {\n        editor.removeNodeByKey(endBlock.key)\n      } else if (isVoidInline) {\n        editor.removeNodeByKey(endInline.key)\n      } else {\n        editor.delete()\n      }\n    })\n\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    debug('onDragEnd', { event })\n    isDraggingInternally = null\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    debug('onDragStart', { event })\n\n    isDraggingInternally = true\n\n    const { value } = editor\n    const { document } = value\n    const node = findNode(event.target, editor)\n    const ancestors = document.getAncestors(node.key)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n    const selectionIncludesNode = value.blocks.some(\n      block => block.key === node.key\n    )\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node)\n    }\n\n    const fragment = editor.value.fragment\n    const encoded = Base64.serializeNode(fragment)\n    setEventTransfer(event, 'fragment', encoded)\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    const { value } = editor\n    const { document, selection } = value\n    const window = getWindow(event.target)\n    let target = getEventRange(event, editor)\n    if (!target) return next()\n\n    debug('onDrop', { event })\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    editor.focus()\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n    if (\n      isDraggingInternally &&\n      selection.end.key == target.end.key &&\n      selection.end.offset < target.end.offset\n    ) {\n      target = target.moveForward(\n        selection.start.key == selection.end.key\n          ? 0 - selection.end.offset + selection.start.offset\n          : 0 - selection.end.offset\n      )\n    }\n\n    if (isDraggingInternally) {\n      editor.delete()\n    }\n\n    editor.select(target)\n\n    if (type == 'text' || type == 'html') {\n      const { anchor } = target\n      let hasVoidParent = document.hasVoidParent(anchor.key, editor)\n\n      if (hasVoidParent) {\n        let n = document.getNode(anchor.key)\n\n        while (hasVoidParent) {\n          n = document.getNextText(n.key)\n          if (!n) break\n          hasVoidParent = document.hasVoidParent(n.key, editor)\n        }\n\n        if (n) editor.moveToStartOfNode(n)\n      }\n\n      if (text) {\n        text.split('\\n').forEach((line, i) => {\n          if (i > 0) editor.splitBlock()\n          editor.insertText(line)\n        })\n      }\n    }\n\n    if (type == 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    const focusNode = document.getNode(target.focus.key)\n    const el = findDOMNode(focusNode, window)\n\n    if (el) {\n      el.dispatchEvent(\n        new MouseEvent('mouseup', {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n        })\n      )\n    }\n\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    debug('onFocus', { event })\n\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n    if (isMouseDown) {\n      editor.deselect().focus()\n    } else {\n      editor.focus()\n    }\n\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    const window = getWindow(event.target)\n    const { value } = editor\n\n    // Get the selection point.\n    const native = window.getSelection()\n    const { anchorNode } = native\n    const point = findPoint(anchorNode, 0, editor)\n    if (!point) return next()\n\n    // Get the text node and leaf in question.\n    const { document, selection } = value\n    const node = document.getDescendant(point.key)\n    const block = document.getClosestBlock(node.key)\n    const leaves = node.getLeaves()\n    const lastText = block.getLastText()\n    const lastLeaf = leaves.last()\n    let start = 0\n    let end = 0\n\n    const leaf =\n      leaves.find(r => {\n        start = end\n        end += r.text.length\n        if (end > point.offset) return true\n      }) || lastLeaf\n\n    // Get the text information.\n    const { text } = leaf\n    let { textContent } = anchorNode\n    const isLastText = node == lastText\n    const isLastLeaf = leaf == lastLeaf\n    const lastChar = textContent.charAt(textContent.length - 1)\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastText && isLastLeaf && lastChar == '\\n') {\n      textContent = textContent.slice(0, -1)\n    }\n\n    // If the text is no different, abort.\n    if (textContent == text) return next()\n\n    debug('onInput', { event })\n\n    // Determine what the selection should be after changing the text.\n    const delta = textContent.length - text.length\n    const corrected = selection.moveToEnd().moveForward(delta)\n    let entire = selection\n      .moveAnchorTo(point.key, start)\n      .moveFocusTo(point.key, end)\n\n    entire = document.resolveRange(entire)\n\n    // Change the current value to have the leaf's text replaced.\n    editor.insertTextAtRange(entire, textContent, leaf.marks).select(corrected)\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', { event })\n\n    const { value } = editor\n    const { document, selection } = value\n    const hasVoidParent = document.hasVoidParent(selection.start.path, editor)\n\n    // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent\n        ? editor.moveToStartOfNextText()\n        : editor.splitBlock()\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward()\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward()\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward()\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward()\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward()\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward()\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo()\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo()\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveToStartOfBlock()\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault()\n      return editor.moveToEndOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToStartOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToEndOfBlock()\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart()\n      }\n\n      return editor.moveBackward()\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd()\n      }\n\n      return editor.moveForward()\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n      return editor.moveWordBackward()\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n      return editor.moveWordForward()\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      const { previousText, startText } = value\n      const isPreviousInVoid =\n        previousText && document.hasVoidParent(previousText.key, editor)\n\n      if (hasVoidParent || isPreviousInVoid || startText.text == '') {\n        event.preventDefault()\n        return editor.moveFocusBackward()\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      const { nextText, startText } = value\n      const isNextInVoid =\n        nextText && document.hasVoidParent(nextText.key, editor)\n\n      if (hasVoidParent || isNextInVoid || startText.text == '') {\n        event.preventDefault()\n        return editor.moveFocusForward()\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseDown(event, editor, next) {\n    debug('onMouseDown', { event })\n    isMouseDown = true\n    next()\n  }\n\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseUp(event, editor, next) {\n    debug('onMouseUp', { event })\n    isMouseDown = false\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    debug('onPaste', { event })\n\n    const { value } = editor\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    if (type == 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    if (type == 'text' || type == 'html') {\n      if (!text) return next()\n      const { document, selection, startBlock } = value\n      if (editor.isVoid(startBlock)) return next()\n\n      const defaultBlock = startBlock\n      const defaultMarks = document.getInsertMarksAtRange(selection)\n      const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n        .document\n      editor.insertFragment(frag)\n    }\n\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event })\n\n    const window = getWindow(event.target)\n    const { value } = editor\n    const { document } = value\n    const native = window.getSelection()\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!native.rangeCount) {\n      editor.blur()\n      return\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    let range = findRange(native, editor)\n\n    if (!range) {\n      return\n    }\n\n    const { anchor, focus } = range\n    const anchorText = document.getNode(anchor.key)\n    const focusText = document.getNode(focus.key)\n    const anchorInline = document.getClosestInline(anchor.key)\n    const focusInline = document.getClosestInline(focus.key)\n    const focusBlock = document.getClosestBlock(focus.key)\n    const anchorBlock = document.getClosestBlock(anchor.key)\n\n    // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n    if (\n      anchorBlock &&\n      !editor.isVoid(anchorBlock) &&\n      anchor.offset == 0 &&\n      focusBlock &&\n      editor.isVoid(focusBlock) &&\n      focus.offset != 0\n    ) {\n      range = range.setFocus(focus.setOffset(0))\n    }\n\n    // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n    if (\n      anchorInline &&\n      !editor.isVoid(anchorInline) &&\n      anchor.offset == anchorText.text.length\n    ) {\n      const block = document.getClosestBlock(anchor.key)\n      const nextText = block.getNextText(anchor.key)\n      if (nextText) range = range.moveAnchorTo(nextText.key, 0)\n    }\n\n    if (\n      focusInline &&\n      !editor.isVoid(focusInline) &&\n      focus.offset == focusText.text.length\n    ) {\n      const block = document.getClosestBlock(focus.key)\n      const nextText = block.getNextText(focus.key)\n      if (nextText) range = range.moveFocusTo(nextText.key, 0)\n    }\n\n    let selection = document.createSelection(range)\n    selection = selection.setIsFocused(true)\n\n    // Preserve active marks from the current selection.\n    // They will be cleared by `editor.select` if the selection actually moved.\n    selection = selection.set('marks', value.selection.marks)\n\n    editor.select(selection)\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onMouseDown,\n    onMouseUp,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AfterPlugin\n","import Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport ReactDOM from 'react-dom'\nimport getWindow from 'get-window'\nimport {\n  IS_FIREFOX,\n  IS_IE,\n  IS_IOS,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport findNode from '../utils/find-node'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:before')\n\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  let activeElement = null\n  let compositionCount = 0\n  let isComposing = false\n  let isCopying = false\n  let isDragging = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const isSynthetic = !!event.nativeEvent\n    if (editor.readOnly) return\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    debug('onBeforeInput', { event })\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const { relatedTarget, target } = event\n    const window = getWindow(target)\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement === window.document.activeElement) return\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      const el = ReactDOM.findDOMNode(editor)\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget === el) return\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute('data-slate-spacer')) return\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      const node = findNode(relatedTarget, editor)\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) return\n    }\n\n    debug('onBlur', { event })\n    next()\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    const n = compositionCount\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n    window.requestAnimationFrame(() => {\n      if (compositionCount > n) return\n      isComposing = false\n    })\n\n    debug('onCompositionEnd', { event })\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    debug('onClick', { event })\n    next()\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true\n    compositionCount++\n\n    const { value } = editor\n    const { selection } = value\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete()\n    }\n\n    debug('onCompositionStart', { event })\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCopy', { event })\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return\n\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCut', { event })\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false\n    debug('onDragEnd', { event })\n    next()\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnter(event, editor, next) {\n    debug('onDragEnter', { event })\n    next()\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragExit(event, editor, next) {\n    debug('onDragExit', { event })\n    next()\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragLeave(event, editor, next) {\n    debug('onDragLeave', { event })\n    next()\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    const node = findNode(event.target, editor)\n    if (editor.isVoid(node)) event.preventDefault()\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (IS_IE) {\n      event.preventDefault()\n    }\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move'\n      }\n    }\n\n    debug('onDragOver', { event })\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    isDragging = true\n    debug('onDragStart', { event })\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault()\n\n    debug('onDrop', { event })\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const el = ReactDOM.findDOMNode(editor)\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (IS_FIREFOX && event.target != el) {\n      el.focus()\n      return\n    }\n\n    debug('onFocus', { event })\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    if (isComposing) return\n    if (editor.value.selection.isBlurred) return\n    debug('onInput', { event })\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault()\n      return\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (\n      !IS_IOS &&\n      (Hotkeys.isBold(event) ||\n        Hotkeys.isDeleteBackward(event) ||\n        Hotkeys.isDeleteForward(event) ||\n        Hotkeys.isDeleteLineBackward(event) ||\n        Hotkeys.isDeleteLineForward(event) ||\n        Hotkeys.isDeleteWordBackward(event) ||\n        Hotkeys.isDeleteWordForward(event) ||\n        Hotkeys.isItalic(event) ||\n        Hotkeys.isRedo(event) ||\n        Hotkeys.isSplitBlock(event) ||\n        Hotkeys.isTransposeCharacter(event) ||\n        Hotkeys.isUndo(event))\n    ) {\n      event.preventDefault()\n    }\n\n    debug('onKeyDown', { event })\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault()\n\n    debug('onPaste', { event })\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return\n    if (isComposing) return\n\n    if (editor.readOnly) return\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    debug('onSelect', { event })\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCompositionEnd,\n    onCompositionStart,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragEnter,\n    onDragExit,\n    onDragLeave,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default BeforePlugin\n","import AfterPlugin from './after'\nimport BeforePlugin from './before'\n\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction DOMPlugin(options = {}) {\n  const { plugins = [] } = options\n  const beforePlugin = BeforePlugin()\n  const afterPlugin = AfterPlugin()\n  return [beforePlugin, ...plugins, afterPlugin]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DOMPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport SlateTypes from 'slate-prop-types'\n\nimport OffsetKey from '../utils/offset-key'\n\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:leaves')\n\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nclass Leaf extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block.isRequired,\n    editor: Types.object.isRequired,\n    index: Types.number.isRequired,\n    leaves: SlateTypes.leaves.isRequired,\n    marks: SlateTypes.marks.isRequired,\n    node: SlateTypes.node.isRequired,\n    offset: Types.number.isRequired,\n    parent: SlateTypes.node.isRequired,\n    text: Types.string.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    debug(message, `${this.props.node.key}-${this.props.index}`, ...args)\n  }\n\n  /**\n   * Should component update?\n   *\n   * @param {Object} props\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(props) {\n    // If any of the regular properties have changed, re-render.\n    if (\n      props.index != this.props.index ||\n      props.marks != this.props.marks ||\n      props.text != this.props.text ||\n      props.parent != this.props.parent\n    ) {\n      return true\n    }\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render the leaf.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n\n    const { node, index } = this.props\n    const offsetKey = OffsetKey.stringify({\n      key: node.key,\n      index,\n    })\n\n    return (\n      <span data-slate-leaf data-offset-key={offsetKey}>\n        {this.renderMarks()}\n      </span>\n    )\n  }\n\n  /**\n   * Render all of the leaf's mark components.\n   *\n   * @return {Element}\n   */\n\n  renderMarks() {\n    const { marks, node, offset, text, editor } = this.props\n    const leaf = this.renderText()\n    const attributes = {\n      'data-slate-mark': true,\n    }\n\n    return marks.reduce((children, mark) => {\n      const props = {\n        editor,\n        mark,\n        marks,\n        node,\n        offset,\n        text,\n        children,\n        attributes,\n      }\n      const element = editor.run('renderMark', props)\n      return element || children\n    }, leaf)\n  }\n\n  /**\n   * Render the text content of the leaf, accounting for browsers.\n   *\n   * @return {Element}\n   */\n\n  renderText() {\n    const { block, node, editor, parent, text, index, leaves } = this.props\n\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (editor.query('isVoid', parent)) {\n      return (\n        <span data-slate-zero-width=\"z\" data-slate-length={parent.text.length}>\n          {'\\uFEFF'}\n        </span>\n      )\n    }\n\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (\n      text === '' &&\n      parent.object === 'block' &&\n      parent.text === '' &&\n      parent.nodes.last() === node\n    ) {\n      return (\n        <span data-slate-zero-width=\"n\" data-slate-length={0}>\n          {'\\uFEFF'}\n          <br />\n        </span>\n      )\n    }\n\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (text === '') {\n      return (\n        <span data-slate-zero-width=\"z\" data-slate-length={0}>\n          {'\\uFEFF'}\n        </span>\n      )\n    }\n\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    const lastText = block.getLastText()\n    const lastChar = text.charAt(text.length - 1)\n    const isLastText = node === lastText\n    const isLastLeaf = index === leaves.size - 1\n    if (isLastText && isLastLeaf && lastChar === '\\n')\n      return <span data-slate-content>{`${text}\\n`}</span>\n\n    // Otherwise, just return the content.\n    return <span data-slate-content>{text}</span>\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Leaf\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport { PathUtils } from 'slate'\n\nimport Leaf from './leaf'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Text.\n *\n * @type {Component}\n */\n\nclass Text extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    style: Types.object,\n  }\n\n  /**\n   * Default prop types.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: null,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key } = node\n    debug(message, `${key} (text)`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate = nextProps => {\n    const { props } = this\n    const n = nextProps\n    const p = props\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node != p.node) return true\n\n    // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    if (n.parent.object == 'block') {\n      const pLast = p.parent.nodes.last()\n      const nLast = n.parent.nodes.last()\n      if (p.node == pLast && n.node != nLast) return true\n    }\n\n    // Re-render if the current decorations have changed.\n    if (!n.decorations.equals(p.decorations)) return true\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n\n    const { decorations, editor, node, style } = this.props\n    const { value } = editor\n    const { document } = value\n    const { key } = node\n\n    const decs = decorations.filter(d => {\n      const { start, end } = d\n\n      // If either of the decoration's keys match, include it.\n      if (start.key === key || end.key === key) return true\n\n      // Otherwise, if the decoration is in a single node, it's not ours.\n      if (start.key === end.key) return false\n\n      // If the node's path is before the start path, ignore it.\n      const path = document.assertPath(key)\n      if (PathUtils.compare(path, start.path) === -1) return false\n\n      // If the node's path is after the end path, ignore it.\n      if (PathUtils.compare(path, end.path) === 1) return false\n\n      // Otherwise, include it.\n      return true\n    })\n\n    // PERF: Take advantage of cache by avoiding arguments\n    const leaves = decs.size === 0 ? node.getLeaves() : node.getLeaves(decs)\n    let offset = 0\n\n    const children = leaves.map((leaf, i) => {\n      const child = this.renderLeaf(leaves, leaf, i, offset)\n      offset += leaf.text.length\n      return child\n    })\n\n    return (\n      <span data-key={key} style={style}>\n        {children}\n      </span>\n    )\n  }\n\n  /**\n   * Render a single leaf given a `leaf` and `offset`.\n   *\n   * @param {List<Leaf>} leaves\n   * @param {Leaf} leaf\n   * @param {Number} index\n   * @param {Number} offset\n   * @return {Element} leaf\n   */\n\n  renderLeaf = (leaves, leaf, index, offset) => {\n    const { block, node, parent, editor } = this.props\n    const { text, marks } = leaf\n\n    return (\n      <Leaf\n        key={`${node.key}-${index}`}\n        block={block}\n        editor={editor}\n        index={index}\n        marks={marks}\n        node={node}\n        offset={offset}\n        parent={parent}\n        leaves={leaves}\n        text={text}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Text\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Text from './text'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:void')\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nclass Void extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    children: Types.any.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    const id = `${key} (${type})`\n    debug(message, `${id}`, ...args)\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props } = this\n    const { children, node, readOnly } = props\n    const Tag = node.object == 'block' ? 'div' : 'span'\n    const style = {\n      height: '0',\n      color: 'transparent',\n      outline: 'none',\n      position: 'absolute',\n    }\n\n    const spacer = (\n      <Tag data-slate-spacer style={style}>\n        {this.renderText()}\n      </Tag>\n    )\n\n    const content = (\n      <Tag contentEditable={readOnly ? null : false}>{children}</Tag>\n    )\n\n    this.debug('render', { props })\n\n    return (\n      <Tag\n        data-slate-void\n        data-key={node.key}\n        contentEditable={readOnly || node.object == 'block' ? null : false}\n      >\n        {readOnly ? null : spacer}\n        {content}\n      </Tag>\n    )\n  }\n\n  /**\n   * Render the void node's text node, which will catch the cursor when it the\n   * void node is navigated to with the arrow keys.\n   *\n   * Having this text node there means the browser continues to manage the\n   * selection natively, so it keeps track of the right offset when moving\n   * across the block.\n   *\n   * @return {Element}\n   */\n\n  renderText = () => {\n    const { block, decorations, node, readOnly, editor } = this.props\n    const child = node.getFirstText()\n    return (\n      <Text\n        block={node.object == 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Void\n","import { Set } from 'immutable'\n\n/**\n * Split the decorations in lists of relevant decorations for each child.\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<List<Decoration>>}\n */\n\nfunction getChildrenDecorations(node, decorations) {\n  const activeDecorations = Set().asMutable()\n  const childrenDecorations = []\n\n  orderChildDecorations(node, decorations).forEach(item => {\n    if (item.isRangeStart) {\n      // Item is a decoration start\n      activeDecorations.add(item.decoration)\n    } else if (item.isRangeEnd) {\n      // item is a decoration end\n      activeDecorations.remove(item.decoration)\n    } else {\n      // Item is a child node\n      childrenDecorations.push(activeDecorations.toList())\n    }\n  })\n\n  return childrenDecorations\n}\n\n/**\n * Orders the children of provided node and its decoration endpoints (start, end)\n * so that decorations can be passed only to relevant children (see use in Node.render())\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<Item>}\n *\n * where type Item =\n * {\n *   child: Node,\n *   // Index of the child in its parent\n *   index: number\n * }\n * or {\n *   // True if this represents the start of the given decoration\n *   isRangeStart: boolean,\n *   // True if this represents the end of the given decoration\n *   isRangeEnd: boolean,\n *   decoration: Range\n * }\n */\n\nfunction orderChildDecorations(node, decorations) {\n  if (decorations.isEmpty()) {\n    return node.nodes.toArray().map((child, index) => ({\n      child,\n      index,\n    }))\n  }\n\n  // Map each key to its global order\n  const keyOrders = { [node.key]: 0 }\n  let globalOrder = 1\n\n  node.forEachDescendant(child => {\n    keyOrders[child.key] = globalOrder\n    globalOrder = globalOrder + 1\n  })\n\n  const childNodes = node.nodes.toArray()\n\n  const endPoints = childNodes.map((child, index) => ({\n    child,\n    index,\n    order: keyOrders[child.key],\n  }))\n\n  decorations.forEach(decoration => {\n    // Range start.\n    // A rangeStart should be before the child containing its startKey, in order\n    // to consider it active before going down the child.\n    const startKeyOrder = keyOrders[decoration.start.key]\n    const containingChildOrder =\n      startKeyOrder === undefined\n        ? 0\n        : getContainingChildOrder(childNodes, keyOrders, startKeyOrder)\n\n    endPoints.push({\n      isRangeStart: true,\n      order: containingChildOrder - 0.5,\n      decoration,\n    })\n\n    // Range end.\n    const endKeyOrder = (keyOrders[decoration.end.key] || globalOrder) + 0.5\n\n    endPoints.push({\n      isRangeEnd: true,\n      order: endKeyOrder,\n      decoration,\n    })\n  })\n\n  return endPoints.sort((a, b) => (a.order > b.order ? 1 : -1))\n}\n\n/*\n * Returns the key order of the child right before the given order.\n */\n\nfunction getContainingChildOrder(children, keyOrders, order) {\n  // Find the first child that is after the given key\n  const nextChildIndex = children.findIndex(\n    child => order < keyOrders[child.key]\n  )\n\n  if (nextChildIndex <= 0) {\n    return 0\n  }\n\n  const containingChild = children[nextChildIndex - 1]\n  return keyOrders[containingChild.key]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getChildrenDecorations\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport warning from 'tiny-warning'\nimport Types from 'prop-types'\n\nimport Void from './void'\nimport Text from './text'\nimport getChildrenDecorations from '../utils/get-children-decorations'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nclass Node extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    isFocused: Types.bool.isRequired,\n    isSelected: Types.bool.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    debug(message, `${key} (${type})`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(nextProps) {\n    const { props } = this\n    const { editor } = props\n    const shouldUpdate = editor.run(\n      'shouldNodeComponentUpdate',\n      props,\n      nextProps\n    )\n    const n = nextProps\n    const p = props\n\n    // If the `Component` has a custom logic to determine whether the component\n    // needs to be updated or not, return true if it returns true. If it returns\n    // false, we need to ignore it, because it shouldn't be allowed it.\n    if (shouldUpdate != null) {\n      if (shouldUpdate) {\n        return true\n      }\n\n      warning(\n        shouldUpdate !== false,\n        \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\"\n      )\n    }\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (n.readOnly != p.readOnly) return true\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node != p.node) return true\n\n    // If the selection value of the node or of some of its children has changed,\n    // re-render in case there is any user-land logic depends on it to render.\n    // if the node is selected update it, even if it was already selected: the\n    // selection value of some of its children could have been changed and they\n    // need to be rendered again.\n    if (n.isSelected || p.isSelected) return true\n    if (n.isFocused || p.isFocused) return true\n\n    // If the decorations have changed, update.\n    if (!n.decorations.equals(p.decorations)) return true\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n    const {\n      editor,\n      isSelected,\n      isFocused,\n      node,\n      decorations,\n      parent,\n      readOnly,\n    } = this.props\n    const { value } = editor\n    const { selection } = value\n    const indexes = node.getSelectionIndexes(selection, isSelected)\n    const decs = decorations.concat(node.getDecorations(editor))\n    const childrenDecorations = getChildrenDecorations(node, decs)\n    const children = []\n\n    node.nodes.forEach((child, i) => {\n      const isChildSelected = !!indexes && indexes.start <= i && i < indexes.end\n\n      children.push(\n        this.renderNode(child, isChildSelected, childrenDecorations[i])\n      )\n    })\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = { 'data-key': node.key }\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.isLeafBlock()) {\n      const direction = node.getTextDirection()\n      if (direction == 'rtl') attributes.dir = 'rtl'\n    }\n\n    const props = {\n      key: node.key,\n      editor,\n      isFocused,\n      isSelected,\n      node,\n      parent,\n      readOnly,\n    }\n\n    const element = editor.run('renderNode', {\n      ...props,\n      attributes,\n      children,\n    })\n\n    return editor.query('isVoid', node) ? (\n      <Void {...this.props}>{element}</Void>\n    ) : (\n      element\n    )\n  }\n\n  /**\n   * Render a `child` node.\n   *\n   * @param {Node} child\n   * @param {Boolean} isSelected\n   * @param {Array<Decoration>} decorations\n   * @return {Element}\n   */\n\n  renderNode = (child, isSelected, decorations) => {\n    const { block, editor, node, readOnly, isFocused } = this.props\n    const Component = child.object == 'text' ? Text : Node\n\n    return (\n      <Component\n        block={node.object == 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        isSelected={isSelected}\n        isFocused={isFocused && isSelected}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Node\n","import findDOMPoint from './find-dom-point'\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range, win = window) {\n  const { anchor, focus, isBackward, isCollapsed } = range\n  const domAnchor = findDOMPoint(anchor, win)\n  const domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win)\n\n  if (!domAnchor || !domFocus) return null\n\n  const r = win.document.createRange()\n  const start = isBackward ? domFocus : domAnchor\n  const end = isBackward ? domAnchor : domFocus\n  r.setStart(start.node, start.offset)\n  r.setEnd(end.node, end.offset)\n  return r\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMRange\n","import getWindow from 'get-window'\nimport isBackward from 'selection-is-backward'\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment'\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll']\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i)\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  let parent = el.parentNode\n  let scroller\n\n  while (!scroller) {\n    if (!parent.parentNode) break\n\n    const style = window.getComputedStyle(parent)\n    const { overflowY } = style\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent\n      break\n    }\n\n    parent = parent.parentNode\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body\n  }\n\n  return scroller\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return\n  if (!selection.anchorNode) return\n\n  const window = getWindow(selection.anchorNode)\n  const scroller = findScrollContainer(selection.anchorNode, window)\n  const isWindow =\n    scroller == window.document.body ||\n    scroller == window.document.documentElement\n  const backward = isBackward(selection)\n\n  const range = selection.getRangeAt(0).cloneRange()\n  range.collapse(backward)\n  let cursorRect = range.getBoundingClientRect()\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top == 0 && cursorRect.height == 0) {\n      if (range.startOffset == 0) {\n        range.setEnd(range.endContainer, 1)\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1)\n      }\n\n      cursorRect = range.getBoundingClientRect()\n\n      if (cursorRect.top == 0 && cursorRect.height == 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0]\n        }\n      }\n    }\n  }\n\n  let width\n  let height\n  let yOffset\n  let xOffset\n  let scrollerTop = 0\n  let scrollerLeft = 0\n  let scrollerBordersY = 0\n  let scrollerBordersX = 0\n  let scrollerPaddingTop = 0\n  let scrollerPaddingBottom = 0\n  let scrollerPaddingLeft = 0\n  let scrollerPaddingRight = 0\n\n  if (isWindow) {\n    const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window\n    width = innerWidth\n    height = innerHeight\n    yOffset = pageYOffset\n    xOffset = pageXOffset\n  } else {\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth,\n      paddingTop,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n    } = window.getComputedStyle(scroller)\n\n    const scrollerRect = scroller.getBoundingClientRect()\n    width = offsetWidth\n    height = offsetHeight\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10)\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10)\n\n    scrollerBordersY =\n      parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10)\n\n    scrollerBordersX =\n      parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10)\n\n    scrollerPaddingTop = parseInt(paddingTop, 10)\n    scrollerPaddingBottom = parseInt(paddingBottom, 10)\n    scrollerPaddingLeft = parseInt(paddingLeft, 10)\n    scrollerPaddingRight = parseInt(paddingRight, 10)\n    yOffset = scrollTop\n    xOffset = scrollLeft\n  }\n\n  const cursorTop = cursorRect.top + yOffset - scrollerTop\n  const cursorLeft = cursorRect.left + xOffset - scrollerLeft\n\n  let x = xOffset\n  let y = yOffset\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft\n  } else if (\n    cursorLeft + cursorRect.width + scrollerBordersX >\n    xOffset + width\n  ) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop\n  } else if (\n    cursorTop + cursorRect.height + scrollerBordersY >\n    yOffset + height\n  ) {\n    // selection below viewport\n    y =\n      cursorTop +\n      scrollerBordersY +\n      scrollerPaddingBottom +\n      cursorRect.height -\n      height\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y)\n  } else {\n    scroller.scrollTop = y\n    scroller.scrollLeft = x\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport getWindow from 'get-window'\nimport warning from 'tiny-warning'\nimport throttle from 'lodash/throttle'\nimport { IS_FIREFOX, HAS_INPUT_EVENTS_LEVEL_2 } from 'slate-dev-environment'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport Node from './node'\nimport findDOMRange from '../utils/find-dom-range'\nimport findRange from '../utils/find-range'\nimport getChildrenDecorations from '../utils/get-children-decorations'\nimport scrollToSelection from '../utils/scroll-to-selection'\nimport removeAllRanges from '../utils/remove-all-ranges'\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:content')\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nclass Content extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool.isRequired,\n    className: Types.string,\n    editor: Types.object.isRequired,\n    id: Types.string,\n    readOnly: Types.bool.isRequired,\n    role: Types.string,\n    spellCheck: Types.bool.isRequired,\n    style: Types.object,\n    tabIndex: Types.number,\n    tagName: Types.string,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: {},\n    tagName: 'div',\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    isUpdatingSelection: false,\n  }\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  componentDidMount() {\n    const window = getWindow(this.element)\n\n    window.document.addEventListener(\n      'selectionchange',\n      this.onNativeSelectionChange\n    )\n\n    // COMPAT: Restrict scope of `beforeinput` to clients that support the\n    // Input Events Level 2 spec, since they are preventable events.\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.element.addEventListener('beforeinput', this.handlers.onBeforeInput)\n    }\n\n    this.updateSelection()\n  }\n\n  /**\n   * When unmounting, remove DOM event listeners.\n   */\n\n  componentWillUnmount() {\n    const window = getWindow(this.element)\n\n    if (window) {\n      window.document.removeEventListener(\n        'selectionchange',\n        this.onNativeSelectionChange\n      )\n    }\n\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.element.removeEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n  }\n\n  /**\n   * On update, update the selection.\n   */\n\n  componentDidUpdate() {\n    this.updateSelection()\n  }\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  updateSelection = () => {\n    const { editor } = this.props\n    const { value } = editor\n    const { selection } = value\n    const { isBackward } = selection\n    const window = getWindow(this.element)\n    const native = window.getSelection()\n    const { activeElement } = window.document\n\n    // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n    if (!native) {\n      return\n    }\n\n    const { rangeCount, anchorNode } = native\n    let updated = false\n\n    // If the Slate selection is blurred, but the DOM's active element is still\n    // the editor, we need to blur it.\n    if (selection.isBlurred && activeElement === this.element) {\n      this.element.blur()\n      updated = true\n    }\n\n    // If the Slate selection is unset, but the DOM selection has a range\n    // selected in the editor, we need to remove the range.\n    if (selection.isUnset && rangeCount && this.isInEditor(anchorNode)) {\n      removeAllRanges(native)\n      updated = true\n    }\n\n    // If the Slate selection is focused, but the DOM's active element is not\n    // the editor, we need to focus it.\n    if (selection.isFocused && activeElement !== this.element) {\n      this.element.focus()\n      updated = true\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    if (selection.isFocused && selection.isSet) {\n      const current = !!rangeCount && native.getRangeAt(0)\n      const range = findDOMRange(selection, window)\n\n      if (!range) {\n        warning(\n          false,\n          'Unable to find a native DOM range from the current selection.'\n        )\n\n        return\n      }\n\n      const { startContainer, startOffset, endContainer, endOffset } = range\n\n      // If the new range matches the current selection, there is nothing to fix.\n      // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n      // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n      // to check both orientations here. (2017/10/31)\n      if (current) {\n        if (\n          (startContainer == current.startContainer &&\n            startOffset == current.startOffset &&\n            endContainer == current.endContainer &&\n            endOffset == current.endOffset) ||\n          (startContainer == current.endContainer &&\n            startOffset == current.endOffset &&\n            endContainer == current.startContainer &&\n            endOffset == current.startOffset)\n        ) {\n          return\n        }\n      }\n\n      // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n      updated = true\n      this.tmp.isUpdatingSelection = true\n      removeAllRanges(native)\n\n      // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n      if (native.setBaseAndExtent) {\n        // COMPAT: Since the DOM range has no concept of backwards/forwards\n        // we need to check and do the right thing here.\n        if (isBackward) {\n          native.setBaseAndExtent(\n            range.endContainer,\n            range.endOffset,\n            range.startContainer,\n            range.startOffset\n          )\n        } else {\n          native.setBaseAndExtent(\n            range.startContainer,\n            range.startOffset,\n            range.endContainer,\n            range.endOffset\n          )\n        }\n      } else {\n        native.addRange(range)\n      }\n\n      // Scroll to the selection, in case it's out of view.\n      scrollToSelection(native)\n\n      // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n      // it is still set when selection-related events from updating it fire.\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (IS_FIREFOX && this.element) {\n          this.element.focus()\n        }\n\n        this.tmp.isUpdatingSelection = false\n      })\n    }\n\n    if (updated) {\n      debug('updateSelection', { selection, native, activeElement })\n    }\n  }\n\n  /**\n   * The React ref method to set the root content element locally.\n   *\n   * @param {Element} element\n   */\n\n  ref = element => {\n    this.element = element\n  }\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  isInEditor = target => {\n    const { element } = this\n\n    let el\n\n    try {\n      // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n      // have .closest and it crashes.\n      if (target.nodeType === 8) {\n        return false\n      }\n\n      // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n      el = target.nodeType === 3 ? target.parentNode : target\n    } catch (err) {\n      // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n      // originating from an internal \"restricted\" element (e.g. a stepper\n      // arrow on a number input)\n      // see github.com/ianstormtaylor/slate/issues/1819\n      if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n        return false\n      }\n\n      throw err\n    }\n\n    return (\n      el.isContentEditable &&\n      (el === element || el.closest('[data-slate-editor]') === element)\n    )\n  }\n\n  /**\n   * On `event` with `handler`.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent(handler, event) {\n    debug('onEvent', handler)\n\n    // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n    // programmatically while updating selection.\n    if (\n      this.tmp.isUpdatingSelection &&\n      (handler == 'onSelect' || handler == 'onBlur' || handler == 'onFocus')\n    ) {\n      return\n    }\n\n    // COMPAT: There are situations where a select event will fire with a new\n    // native selection that resolves to the same internal position. In those\n    // cases we don't need to trigger any changes, since our internal model is\n    // already up to date, but we do want to update the native selection again\n    // to make sure it is in sync. (2017/10/16)\n    if (handler == 'onSelect') {\n      const { editor } = this.props\n      const { value } = editor\n      const { selection } = value\n      const window = getWindow(event.target)\n      const native = window.getSelection()\n      const range = findRange(native, editor)\n\n      if (range && range.equals(selection.toRange())) {\n        this.updateSelection()\n        return\n      }\n    }\n\n    // Don't handle drag and drop events coming from embedded editors.\n    if (\n      handler == 'onDragEnd' ||\n      handler == 'onDragEnter' ||\n      handler == 'onDragExit' ||\n      handler == 'onDragLeave' ||\n      handler == 'onDragOver' ||\n      handler == 'onDragStart' ||\n      handler == 'onDrop'\n    ) {\n      const closest = event.target.closest('[data-slate-editor]')\n\n      if (closest !== this.element) {\n        return\n      }\n    }\n\n    // Some events require being in editable in the editor, so if the event\n    // target isn't, ignore them.\n    if (\n      handler == 'onBeforeInput' ||\n      handler == 'onBlur' ||\n      handler == 'onCompositionEnd' ||\n      handler == 'onCompositionStart' ||\n      handler == 'onCopy' ||\n      handler == 'onCut' ||\n      handler == 'onFocus' ||\n      handler == 'onInput' ||\n      handler == 'onKeyDown' ||\n      handler == 'onKeyUp' ||\n      handler == 'onPaste' ||\n      handler == 'onSelect'\n    ) {\n      if (!this.isInEditor(event.target)) {\n        return\n      }\n    }\n\n    this.props.onEvent(handler, event)\n  }\n\n  /**\n   * On native `selectionchange` event, trigger the `onSelect` handler. This is\n   * needed to account for React's `onSelect` being non-standard and not firing\n   * until after a selection has been released. This causes issues in situations\n   * where another change happens while a selection is being made.\n   *\n   * @param {Event} event\n   */\n\n  onNativeSelectionChange = throttle(event => {\n    if (this.props.readOnly) return\n\n    const window = getWindow(event.target)\n    const { activeElement } = window.document\n    if (activeElement !== this.element) return\n\n    this.props.onEvent('onSelect', event)\n  }, 100)\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props, handlers } = this\n    const {\n      id,\n      className,\n      readOnly,\n      editor,\n      tabIndex,\n      role,\n      tagName,\n      spellCheck,\n    } = props\n    const { value } = editor\n    const Container = tagName\n    const { document, selection, decorations } = value\n    const indexes = document.getSelectionIndexes(selection)\n    const decs = document.getDecorations(editor).concat(decorations)\n    const childrenDecorations = getChildrenDecorations(document, decs)\n\n    const children = document.nodes.toArray().map((child, i) => {\n      const isSelected = !!indexes && indexes.start <= i && i < indexes.end\n\n      return this.renderNode(child, isSelected, childrenDecorations[i])\n    })\n\n    const style = {\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word',\n      // COMPAT: In iOS, a formatting menu with bold, italic and underline\n      // buttons is shown which causes our internal value to get out of sync in\n      // weird ways. This hides that. (2016/06/21)\n      ...(readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }),\n      // Allow for passed-in styles to override anything.\n      ...props.style,\n    }\n\n    debug('render', { props })\n\n    return (\n      <Container\n        {...handlers}\n        data-slate-editor\n        ref={this.ref}\n        data-key={document.key}\n        contentEditable={readOnly ? null : true}\n        suppressContentEditableWarning\n        id={id}\n        className={className}\n        autoCorrect={props.autoCorrect ? 'on' : 'off'}\n        spellCheck={spellCheck}\n        style={style}\n        role={readOnly ? null : role || 'textbox'}\n        tabIndex={tabIndex}\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        data-gramm={false}\n      >\n        {children}\n      </Container>\n    )\n  }\n\n  /**\n   * Render a `child` node of the document.\n   *\n   * @param {Node} child\n   * @param {Boolean} isSelected\n   * @return {Element}\n   */\n\n  renderNode = (child, isSelected, decorations) => {\n    const { editor, readOnly } = this.props\n    const { value } = editor\n    const { document, selection } = value\n    const { isFocused } = selection\n\n    return (\n      <Node\n        block={null}\n        editor={editor}\n        decorations={decorations}\n        isSelected={isSelected}\n        isFocused={isFocused && isSelected}\n        key={child.key}\n        node={child}\n        parent={document}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Content\n","import PlaceholderPlugin from 'slate-react-placeholder'\nimport React from 'react'\n\nimport DOMPlugin from './dom'\nimport Content from '../components/content'\nimport EVENT_HANDLERS from '../constants/event-handlers'\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nconst PROPS = [\n  ...EVENT_HANDLERS,\n  'commands',\n  'decorateNode',\n  'queries',\n  'renderEditor',\n  'renderMark',\n  'renderNode',\n  'schema',\n]\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin(options = {}) {\n  const { placeholder, plugins = [] } = options\n\n  /**\n   * Decorate node.\n   *\n   * @param {Object} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    return []\n  }\n\n  /**\n   * Render editor.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n  function renderEditor(props, editor, next) {\n    return (\n      <Content\n        autoCorrect={props.autoCorrect}\n        className={props.className}\n        editor={editor}\n        id={props.id}\n        onEvent={(handler, event) => editor.run(handler, event)}\n        readOnly={props.readOnly}\n        role={props.role}\n        spellCheck={props.spellCheck}\n        style={props.style}\n        tabIndex={props.tabIndex}\n        tagName={props.tagName}\n      />\n    )\n  }\n\n  /**\n   * Render node.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n  function renderNode(props, editor, next) {\n    const { attributes, children, node } = props\n    const { object } = node\n    if (object != 'block' && object != 'inline') return null\n\n    const Tag = object == 'block' ? 'div' : 'span'\n    const style = { position: 'relative' }\n    return (\n      <Tag {...attributes} style={style}>\n        {children}\n      </Tag>\n    )\n  }\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  const ret = []\n  const editorPlugin = PROPS.reduce((memo, prop) => {\n    if (prop in options) memo[prop] = options[prop]\n    return memo\n  }, {})\n\n  ret.push(\n    DOMPlugin({\n      plugins: [editorPlugin, ...plugins],\n    })\n  )\n\n  if (placeholder) {\n    ret.push(\n      PlaceholderPlugin({\n        placeholder,\n        when: (editor, node) =>\n          node.object === 'document' &&\n          node.text === '' &&\n          node.nodes.size === 1 &&\n          node.getTexts().size === 1,\n      })\n    )\n  }\n\n  ret.push({\n    decorateNode,\n    renderEditor,\n    renderNode,\n  })\n\n  return ret\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default ReactPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport invariant from 'tiny-invariant'\nimport memoizeOne from 'memoize-one'\nimport warning from 'tiny-warning'\nimport { Editor as Controller } from 'slate'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport ReactPlugin from '../plugins/react'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nclass Editor extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool,\n    autoFocus: Types.bool,\n    className: Types.string,\n    id: Types.string,\n    onChange: Types.func,\n    options: Types.object,\n    placeholder: Types.any,\n    plugins: Types.array,\n    readOnly: Types.bool,\n    role: Types.string,\n    schema: Types.object,\n    spellCheck: Types.bool,\n    style: Types.object,\n    tabIndex: Types.number,\n    value: SlateTypes.value.isRequired,\n    ...EVENT_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    autoFocus: false,\n    autoCorrect: true,\n    onChange: () => {},\n    options: {},\n    placeholder: '',\n    plugins: [],\n    readOnly: false,\n    schema: {},\n    spellCheck: true,\n  }\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  state = {}\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    mounted: false,\n    change: null,\n    resolves: 0,\n    updates: 0,\n  }\n\n  /**\n   * When the component first mounts, flush a queued change if one exists.\n   */\n\n  componentDidMount() {\n    this.tmp.mounted = true\n    this.tmp.updates++\n\n    if (this.props.autoFocus) {\n      this.focus()\n    }\n\n    if (this.tmp.change) {\n      this.props.onChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component updates, flush a queued change if one exists.\n   */\n\n  componentDidUpdate() {\n    this.tmp.updates++\n\n    if (this.tmp.change) {\n      this.props.onChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component unmounts, make sure async commands don't trigger react updates.\n   */\n\n  componentWillUnmount() {\n    this.tmp.mounted = false\n  }\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    debug('render', this)\n    const props = { ...this.props, editor: this }\n\n    // Re-resolve the controller if needed based on memoized props.\n    const { commands, placeholder, plugins, queries, schema } = props\n    this.resolveController(plugins, schema, commands, queries, placeholder)\n\n    // Set the current props on the controller.\n    const { options, readOnly, value } = props\n    this.controller.setReadOnly(readOnly)\n    this.controller.setValue(value, options)\n\n    // Render the editor's children with the controller.\n    const children = this.controller.run('renderEditor', props)\n    return children\n  }\n\n  /**\n   * Resolve an editor controller from the passed-in props. This method takes\n   * all of the props as individual arguments to be able to properly memoize\n   * against anything that could change and invalidate the old editor.\n   *\n   * @param {Array} plugins\n   * @param {Object} schema\n   * @param {Object} commands\n   * @param {Object} queries\n   * @param {String} placeholder\n   * @return {Editor}\n   */\n\n  resolveController = memoizeOne(\n    (plugins = [], schema, commands, queries, placeholder) => {\n      // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n      warning(\n        this.tmp.resolves < 5 || this.tmp.resolves !== this.tmp.updates,\n        'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.'\n      )\n\n      this.tmp.resolves++\n      const react = ReactPlugin(this.props)\n\n      const onChange = change => {\n        if (this.tmp.mounted) {\n          this.props.onChange(change)\n        } else {\n          this.tmp.change = change\n        }\n      }\n\n      this.controller = new Controller(\n        { plugins: [react], onChange },\n        { controller: this, construct: false }\n      )\n\n      this.controller.run('onConstruct')\n    }\n  )\n\n  /**\n   * Mimic the API of the `Editor` controller, so that this component instance\n   * can be passed in its place to plugins.\n   */\n\n  get operations() {\n    return this.controller.operations\n  }\n\n  get readOnly() {\n    return this.controller.readOnly\n  }\n\n  get value() {\n    return this.controller.value\n  }\n\n  applyOperation(...args) {\n    return this.controller.applyOperation(...args)\n  }\n\n  command(...args) {\n    return this.controller.command(...args)\n  }\n\n  normalize(...args) {\n    return this.controller.normalize(...args)\n  }\n\n  query(...args) {\n    return this.controller.query(...args)\n  }\n\n  registerCommand(...args) {\n    return this.controller.registerCommand(...args)\n  }\n\n  registerQuery(...args) {\n    return this.controller.registerQuery(...args)\n  }\n\n  run(...args) {\n    return this.controller.run(...args)\n  }\n\n  withoutNormalizing(...args) {\n    return this.controller.withoutNormalizing(...args)\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    return this.controller.editor\n  }\n\n  get schema() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  get stack() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  call(...args) {\n    return this.controller.call(...args)\n  }\n\n  change(...args) {\n    return this.controller.change(...args)\n  }\n\n  onChange(...args) {\n    return this.controller.onChange(...args)\n  }\n\n  applyOperations(...args) {\n    return this.controller.applyOperations(...args)\n  }\n\n  setOperationFlag(...args) {\n    return this.controller.setOperationFlag(...args)\n  }\n\n  getFlag(...args) {\n    return this.controller.getFlag(...args)\n  }\n\n  unsetOperationFlag(...args) {\n    return this.controller.unsetOperationFlag(...args)\n  }\n\n  withoutNormalization(...args) {\n    return this.controller.withoutNormalization(...args)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Editor\n","import Editor from './components/editor'\nimport cloneFragment from './utils/clone-fragment'\nimport findDOMNode from './utils/find-dom-node'\nimport findDOMRange from './utils/find-dom-range'\nimport findNode from './utils/find-node'\nimport findRange from './utils/find-range'\nimport getEventRange from './utils/get-event-range'\nimport getEventTransfer from './utils/get-event-transfer'\nimport setEventTransfer from './utils/set-event-transfer'\nimport ReactPlugin from './plugins/react'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMRange,\n  findNode,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n\nexport default {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMRange,\n  findNode,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n"],"names":["EVENT_HANDLERS","TRANSFER_TYPES","findDOMNode","key","win","window","Node","isNode","el","document","querySelector","Error","removeAllRanges","selection","doc","body","createTextRange","range","collapse","select","PARSER","parse","string","matches","exec","original","index","parseInt","stringify","object","ZERO_WIDTH_ATTRIBUTE","ZERO_WIDTH_SELECTOR","OFFSET_KEY_ATTRIBUTE","RANGE_SELECTOR","TEXT_SELECTOR","VOID_SELECTOR","findPoint","nativeNode","nativeOffset","editor","Value","isValue","normalizeNodeAndOffset","nearestNode","node","nearestOffset","offset","getWindow","parentNode","rangeNode","closest","createRange","textNode","setStart","setEnd","toString","length","voidNode","textContent","hasAttribute","offsetKey","getAttribute","OffsetKey","value","hasDescendant","point","createPoint","nodeType","childNodes","isLast","direction","getEditableChild","i","parent","child","triedForward","triedBackward","FRAGMENT","HTML","TEXT","cloneFragment","event","callback","undefined","target","native","getSelection","fragment","start","end","startVoid","getClosestVoid","endVoid","isCollapsed","encoded","Base64","serializeNode","getRangeAt","contents","cloneContents","attach","forEach","trim","r","cloneRange","setEndAfter","firstChild","slice","call","querySelectorAll","isNewline","zw","span","createElement","style","whiteSpace","appendChild","setAttribute","valFromSelection","create","plainText","Plain","serialize","div","clipboardData","setData","IS_IE","preventDefault","innerHTML","editorEl","position","left","selectAllChildren","requestAnimationFrame","removeChild","addRange","findNode","element","getNode","findDOMPoint","texts","Array","from","text","domLength","slateLength","Math","min","max","findRange","anchorNode","startContainer","Range","StaticRange","startOffset","endContainer","endOffset","anchorOffset","focusNode","focusOffset","anchor","focus","IS_EDGE","domAnchor","domFocus","getEventRange","nativeEvent","x","y","query","rect","getBoundingClientRect","isPrevious","width","top","height","getFirstText","previousText","getPreviousText","moveToEndOfNode","nextText","getNextText","moveToStartOfNode","caretRangeFromPoint","caretPositionFromPoint","offsetNode","moveToPoint","error","NODE","RICH","FRAGMENT_MATCHER","getEventTransfer","transfer","dataTransfer","getType","html","rich","files","indexOf","full","embeddedTypes","getEmbeddedTypes","deserializeNode","items","map","item","kind","getAsFile","filter","exists","err","data","type","getTransferType","prefix","substring","JSON","types","getData","setEventTransfer","content","mime","toUpperCase","obj","e","debug","Debug","AfterPlugin","isDraggingInternally","isMouseDown","onBeforeInput","next","isSynthetic","insertText","getTargetRanges","targetRange","inputType","deleteAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","deleteLineBackwardAtRange","deleteLineForwardAtRange","hasVoidParent","path","moveToStartOfNextText","splitBlockAtRange","insertTextAtRange","marks","onBlur","blur","onClick","readOnly","ancestors","getAncestors","isVoid","some","a","onCopy","onCut","endBlock","endInline","isVoidBlock","isVoidInline","removeNodeByKey","delete","onDragEnd","onDragStart","selectionIncludesNode","blocks","block","moveToRangeOfNode","onDrop","moveForward","n","split","line","splitBlock","insertFragment","dispatchEvent","MouseEvent","onFocus","deselect","onInput","getDescendant","getClosestBlock","leaves","getLeaves","lastText","getLastText","lastLeaf","last","leaf","find","isLastText","isLastLeaf","lastChar","charAt","delta","corrected","moveToEnd","entire","moveAnchorTo","moveFocusTo","resolveRange","onKeyDown","Hotkeys","isSplitBlock","IS_IOS","isDeleteBackward","deleteCharBackward","isDeleteForward","deleteCharForward","isDeleteLineBackward","deleteLineBackward","isDeleteLineForward","deleteLineForward","isDeleteWordBackward","deleteWordBackward","isDeleteWordForward","deleteWordForward","isRedo","redo","isUndo","undo","isMoveLineBackward","moveToStartOfBlock","isMoveLineForward","moveToEndOfBlock","isExtendLineBackward","moveFocusToStartOfBlock","isExtendLineForward","moveFocusToEndOfBlock","isMoveBackward","moveToStart","moveBackward","isMoveForward","isMoveWordBackward","moveWordBackward","isMoveWordForward","moveWordForward","isExtendBackward","startText","isPreviousInVoid","moveFocusBackward","isExtendForward","isNextInVoid","moveFocusForward","onMouseDown","onMouseUp","onPaste","startBlock","defaultBlock","defaultMarks","getInsertMarksAtRange","frag","deserialize","onSelect","rangeCount","anchorText","focusText","anchorInline","getClosestInline","focusInline","focusBlock","anchorBlock","setFocus","setOffset","createSelection","setIsFocused","set","BeforePlugin","activeElement","compositionCount","isComposing","isCopying","isDragging","HAS_INPUT_EVENTS_LEVEL_2","relatedTarget","ReactDOM","contains","onCompositionEnd","onCompositionStart","onDragEnter","onDragExit","onDragLeave","onDragOver","dropEffect","IS_FIREFOX","isBlurred","isCompose","isBold","isItalic","isTransposeCharacter","DOMPlugin","options","plugins","beforePlugin","afterPlugin","Leaf","props","renderMarks","renderText","attributes","reduce","children","mark","run","nodes","size","React","Component","propTypes","SlateTypes","isRequired","Types","number","message","args","Text","decorations","decs","d","assertPath","PathUtils","compare","renderLeaf","ImmutableTypes","list","defaultProps","shouldComponentUpdate","nextProps","p","pLast","nLast","equals","Void","Tag","spacer","any","bool","id","getChildrenDecorations","activeDecorations","Set","asMutable","childrenDecorations","isRangeStart","add","decoration","isRangeEnd","remove","push","toList","orderChildDecorations","isEmpty","toArray","keyOrders","globalOrder","forEachDescendant","endPoints","startKeyOrder","containingChildOrder","getContainingChildOrder","endKeyOrder","sort","b","order","nextChildIndex","findIndex","containingChild","shouldUpdate","isSelected","isFocused","indexes","getSelectionIndexes","concat","getDecorations","isChildSelected","renderNode","isLeafBlock","getTextDirection","dir","findDOMRange","isBackward","OVERFLOWS","IS_IOS_11","navigator","userAgent","match","findScrollContainer","scroller","getComputedStyle","overflowY","includes","scrollToSelection","isWindow","documentElement","backward","cursorRect","IS_SAFARI","collapsed","getClientRects","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","cursorTop","cursorLeft","scrollTo","FIREFOX_NODE_TYPE_ACCESS_ERROR","Content","tmp","handlers","handler","onEvent","updateSelection","updated","isUnset","isInEditor","isSet","current","isUpdatingSelection","setBaseAndExtent","ref","test","isContentEditable","onNativeSelectionChange","throttle","addEventListener","removeEventListener","toRange","className","tabIndex","role","tagName","spellCheck","Container","WebkitUserModify","autoCorrect","PROPS","ReactPlugin","placeholder","decorateNode","renderEditor","ret","editorPlugin","memo","prop","PlaceholderPlugin","getTexts","Editor","state","resolveController","memoizeOne","resolves","updates","react","onChange","mounted","change","controller","Controller","construct","autoFocus","commands","queries","schema","setReadOnly","setValue","applyOperation","command","normalize","registerCommand","registerQuery","withoutNormalizing","applyOperations","setOperationFlag","getFlag","unsetOperationFlag","withoutNormalization","operations","func","array"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;;;;AAMA,IAAMA,iBAAiB,CACrB,eADqB,EAErB,QAFqB,EAGrB,SAHqB,EAIrB,eAJqB,EAKrB,kBALqB,EAMrB,oBANqB,EAOrB,QAPqB,EAQrB,OARqB,EASrB,WATqB,EAUrB,aAVqB,EAWrB,YAXqB,EAYrB,aAZqB,EAarB,YAbqB,EAcrB,aAdqB,EAerB,QAfqB,EAgBrB,SAhBqB,EAiBrB,SAjBqB,EAkBrB,WAlBqB,EAmBrB,SAnBqB,EAoBrB,aApBqB,EAqBrB,WArBqB,EAsBrB,SAtBqB,EAuBrB,UAvBqB,CAAvB;;ACNA;;;;;;AAMA,IAAMC,iBAAiB;YACX,8BADW;QAEf,WAFe;QAGf,0BAHe;QAIf,UAJe;QAKf;;;;;;;;CALR;;ACJA;;;;;;;;AAQA,SAASC,WAAT,CAAqBC,GAArB,EAAwC;MAAdC,GAAc,uEAARC,MAAQ;;MAClCC,KAAKC,MAAL,CAAYJ,GAAZ,CAAJ,EAAsB;UACdA,IAAIA,GAAV;;;MAGIK,KAAKJ,IAAIK,QAAJ,CAAaC,aAAb,iBAAyCP,GAAzC,QAAX;;MAEI,CAACK,EAAL,EAAS;UACD,IAAIG,KAAJ,qCAC8BR,GAD9B,6FAAN;;;SAKKK,EAAP;;;ACvBF;;;;;;;;AAQA,SAASI,eAAT,CAAyBC,SAAzB,EAAoC;MAC5BC,MAAMT,OAAOI,QAAnB;;MAEIK,OAAOA,IAAIC,IAAJ,CAASC,eAApB,EAAqC;;QAE7BC,QAAQH,IAAIC,IAAJ,CAASC,eAAT,EAAd;UACME,QAAN;UACMC,MAAN;GAJF,MAKO;cACKP,eAAV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBJ;;;;;;AAMA,IAAMQ,SAAS,uBAAf;;;;;;;;;AASA,SAASC,KAAT,CAAeC,MAAf,EAAuB;MACfC,UAAUH,OAAOI,IAAP,CAAYF,MAAZ,CAAhB;;MAEI,CAACC,OAAL,EAAc;UACN,IAAIZ,KAAJ,kCAAwCW,MAAxC,SAAN;;;+BAG6BC,OAPV;MAOdE,QAPc;MAOJtB,GAPI;MAOCuB,KAPD;;;SAQd;YAAA;WAEEC,SAASD,KAAT,EAAgB,EAAhB;GAFT;;;;;;;;;;;;AAeF,SAASE,SAAT,CAAmBC,MAAnB,EAA2B;SACfA,OAAO1B,GAAjB,SAAwB0B,OAAOH,KAA/B;;;;;;;;;AASF,gBAAe;cAAA;;CAAf;;AC1CA;;;;;;AAMA,AAAO,IAAMI,uBAAuB,uBAA7B;AACP,AAAO,IAAMC,4BAA0BD,oBAA1B,MAAN;AACP,IAAME,uBAAuB,iBAA7B;AACA,IAAMC,uBAAqBD,oBAArB,MAAN;AACA,IAAME,4BAAN;AACA,IAAMC,gBAAgB,mBAAtB;;;;;;;;;;;AAWA,SAASC,SAAT,CAAmBC,UAAnB,EAA+BC,YAA/B,EAA6CC,MAA7C,EAAqD;YAEjD,CAACC,MAAMC,OAAN,CAAcF,MAAd,CADH,EAEE,qFAFF;;8BAKqDG,uBACnDL,UADmD,EAEnDC,YAFmD,CANF;MAMrCK,WANqC,yBAM3CC,IAN2C;MAMhBC,aANgB,yBAMxBC,MANwB;;MAW7CzC,SAAS0C,UAAUV,UAAV,CAAf;MACQW,UAZ2C,GAY5BL,WAZ4B,CAY3CK,UAZ2C;;MAa/CC,YAAYD,WAAWE,OAAX,CAAmBjB,cAAnB,CAAhB;MACIa,eAAJ;MACIF,aAAJ;;;;MAIIK,SAAJ,EAAe;QACPhC,QAAQZ,OAAOI,QAAP,CAAgB0C,WAAhB,EAAd;QACMC,WAAWH,UAAUC,OAAV,CAAkBhB,aAAlB,CAAjB;UACMmB,QAAN,CAAeD,QAAf,EAAyB,CAAzB;UACME,MAAN,CAAaX,WAAb,EAA0BE,aAA1B;WACOO,QAAP;aACSnC,MAAMsC,QAAN,GAAiBC,MAA1B;GANF,MAOO;;;QAGCC,WAAWT,WAAWE,OAAX,CAAmBf,aAAnB,CAAjB;QACI,CAACsB,QAAL,EAAe,OAAO,IAAP;gBACHA,SAAS/C,aAAT,CAAuBuB,cAAvB,CAAZ;QACI,CAACgB,SAAL,EAAgB,OAAO,IAAP;WACTA,SAAP;aACSL,KAAKc,WAAL,CAAiBF,MAA1B;;;;;;;MAQAV,UAAUF,KAAKc,WAAL,CAAiBF,MAA3B,IACAR,WAAWW,YAAX,CAAwB7B,oBAAxB,CAFF,EAGE;;;;;MAKI8B,YAAYX,UAAUY,YAAV,CAAuB7B,oBAAvB,CAAlB;MACI,CAAC4B,SAAL,EAAgB,OAAO,IAAP;;yBAEAE,UAAUzC,KAAV,CAAgBuC,SAAhB,CApDmC;MAoD3CzD,GApD2C,oBAoD3CA,GApD2C;;;;;;;MAyD3C4D,KAzD2C,GAyDjCxB,MAzDiC,CAyD3CwB,KAzD2C;;MA0D/C,CAACA,MAAMtD,QAAN,CAAeuD,aAAf,CAA6B7D,GAA7B,CAAL,EAAwC,OAAO,IAAP;;MAElC8D,QAAQF,MAAMtD,QAAN,CAAeyD,WAAf,CAA2B,EAAE/D,QAAF,EAAO2C,cAAP,EAA3B,CAAd;SACOmB,KAAP;;;;;;;;;;;;AAYF,SAASvB,sBAAT,CAAgCE,IAAhC,EAAsCE,MAAtC,EAA8C;;;MAGxCF,KAAKuB,QAAL,IAAiB,CAAjB,IAAsBvB,KAAKwB,UAAL,CAAgBZ,MAA1C,EAAkD;QAC1Ca,SAASvB,UAAUF,KAAKwB,UAAL,CAAgBZ,MAAzC;QACMc,YAAYD,SAAS,UAAT,GAAsB,SAAxC;QACM3C,QAAQ2C,SAASvB,SAAS,CAAlB,GAAsBA,MAApC;WACOyB,iBAAiB3B,IAAjB,EAAuBlB,KAAvB,EAA8B4C,SAA9B,CAAP;;;;WAIO1B,KAAKuB,QAAL,IAAiB,CAAjB,IAAsBvB,KAAKwB,UAAL,CAAgBZ,MAA7C,EAAqD;UAC7CgB,IAAIH,SAASzB,KAAKwB,UAAL,CAAgBZ,MAAhB,GAAyB,CAAlC,GAAsC,CAAhD;aACOe,iBAAiB3B,IAAjB,EAAuB4B,CAAvB,EAA0BF,SAA1B,CAAP;;;;aAIOD,SAASzB,KAAKc,WAAL,CAAiBF,MAA1B,GAAmC,CAA5C;;;;SAIK,EAAEZ,UAAF,EAAQE,cAAR,EAAP;;;;;;;;;;;;;AAaF,SAASyB,gBAAT,CAA0BE,MAA1B,EAAkC/C,KAAlC,EAAyC4C,SAAzC,EAAoD;MAC1CF,UAD0C,GAC3BK,MAD2B,CAC1CL,UAD0C;;MAE9CM,QAAQN,WAAW1C,KAAX,CAAZ;MACI8C,IAAI9C,KAAR;MACIiD,eAAe,KAAnB;MACIC,gBAAgB,KAApB;;;;SAKEF,MAAMP,QAAN,IAAkB,CAAlB,IACCO,MAAMP,QAAN,IAAkB,CAAlB,IAAuBO,MAAMN,UAAN,CAAiBZ,MAAjB,IAA2B,CADnD,IAECkB,MAAMP,QAAN,IAAkB,CAAlB,IAAuBO,MAAMb,YAAN,CAAmB,iBAAnB,KAAyC,OAHnE,EAIE;QACIc,gBAAgBC,aAApB,EAAmC;;QAE/BJ,KAAKJ,WAAWZ,MAApB,EAA4B;qBACX,IAAf;UACI9B,QAAQ,CAAZ;kBACY,UAAZ;;;;QAIE8C,IAAI,CAAR,EAAW;sBACO,IAAhB;UACI9C,QAAQ,CAAZ;kBACY,SAAZ;;;;YAIM0C,WAAWI,CAAX,CAAR;QACIF,aAAa,SAAjB,EAA4BE;QACxBF,aAAa,UAAjB,EAA6BE;;;SAGxBE,SAAS,IAAhB;;;IC/JMG,WAAyB5E,eAAzB4E;IAAUC,OAAe7E,eAAf6E;IAAMC,OAAS9E,eAAT8E;;;;;;;;;AASxB,SAASC,aAAT,CAAuBC,KAAvB,EAA8B1C,MAA9B,EAAkE;MAA5B2C,QAA4B,uEAAjB;WAAMC,SAAN;GAAiB;;YAE9D,CAAC3C,MAAMC,OAAN,CAAcF,MAAd,CADH,EAEE,yFAFF;;MAKMlC,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;MACMC,SAAShF,OAAOiF,YAAP,EAAf;MACQvB,KARwD,GAQ9CxB,MAR8C,CAQxDwB,KARwD;MASxDtD,QATwD,GAStBsD,KATsB,CASxDtD,QATwD;MAS9C8E,QAT8C,GAStBxB,KATsB,CAS9CwB,QAT8C;MASpC1E,SAToC,GAStBkD,KATsB,CASpClD,SAToC;MAUxD2E,KAVwD,GAUzC3E,SAVyC,CAUxD2E,KAVwD;MAUjDC,GAViD,GAUzC5E,SAVyC,CAUjD4E,GAViD;;MAW1DC,YAAYjF,SAASkF,cAAT,CAAwBH,MAAMrF,GAA9B,EAAmCoC,MAAnC,CAAlB;MACMqD,UAAUnF,SAASkF,cAAT,CAAwBF,IAAItF,GAA5B,EAAiCoC,MAAjC,CAAhB;;;MAGI8C,OAAOQ,WAAP,IAAsB,CAACH,SAA3B,EAAsC;;;;MAIhCI,UAAUC,OAAOC,aAAP,CAAqBT,QAArB,CAAhB;MACMtE,QAAQoE,OAAOY,UAAP,CAAkB,CAAlB,CAAd;MACIC,WAAWjF,MAAMkF,aAAN,EAAf;MACIC,SAASF,SAAS9B,UAAT,CAAoB,CAApB,CAAb;;;WAGSA,UAAT,CAAoBiC,OAApB,CAA4B,gBAAQ;QAC9BzD,KAAKc,WAAL,IAAoBd,KAAKc,WAAL,CAAiB4C,IAAjB,OAA4B,EAApD,EAAwD;eAC7C1D,IAAT;;GAFJ;;;;;MASIgD,OAAJ,EAAa;QACLW,IAAItF,MAAMuF,UAAN,EAAV;QACM5D,OAAO1C,YAAY0F,OAAZ,EAAqBvF,MAArB,CAAb;MACEoG,WAAF,CAAc7D,IAAd;eACW2D,EAAEJ,aAAF,EAAX;;;;;;;MAOET,SAAJ,EAAe;aACJQ,SAAS9B,UAAT,CAAoB,CAApB,EAAuBA,UAAvB,CAAkC,CAAlC,EAAqCsC,UAA9C;;;;;EAKD,GAAGC,KAAH,CAASC,IAAT,CAAcV,SAASW,gBAAT,CAA0B9E,mBAA1B,CAAd,EAA8DsE,OAA9D,CAAsE,cAAM;QACrES,YAAYC,GAAGlD,YAAH,CAAgB/B,oBAAhB,MAA0C,GAA5D;OACG4B,WAAH,GAAiBoD,YAAY,IAAZ,GAAmB,EAApC;GAFD;;;;;MAQGV,OAAOjC,QAAP,IAAmB,CAAvB,EAA0B;QAClB6C,OAAO3G,OAAOI,QAAP,CAAgBwG,aAAhB,CAA8B,MAA9B,CAAb;;;;SAIKC,KAAL,CAAWC,UAAX,GAAwB,KAAxB;;SAEKC,WAAL,CAAiBhB,MAAjB;aACSgB,WAAT,CAAqBJ,IAArB;aACSA,IAAT;;;SAGKK,YAAP,CAAoB,qBAApB,EAA2CvB,OAA3C;;;;;MAKMwB,mBAAmB9E,MAAM+E,MAAN,CAAa,EAAE9G,UAAU8E,QAAZ,EAAb,CAAzB;MACMiC,YAAYC,MAAMC,SAAN,CAAgBJ,gBAAhB,CAAlB;;;;MAIMK,MAAMtH,OAAOI,QAAP,CAAgBwG,aAAhB,CAA8B,KAA9B,CAAZ;MACIG,WAAJ,CAAgBlB,QAAhB;;;;;;;;MAQIjB,MAAM2C,aAAN,IAAuB3C,MAAM2C,aAAN,CAAoBC,OAA3C,IAAsD,CAACC,KAA3D,EAAkE;UAC1DC,cAAN;UACMH,aAAN,CAAoBC,OAApB,CAA4B9C,IAA5B,EAAkCyC,SAAlC;UACMI,aAAN,CAAoBC,OAApB,CAA4BhD,QAA5B,EAAsCiB,OAAtC;UACM8B,aAAN,CAAoBC,OAApB,CAA4B/C,IAA5B,EAAkC6C,IAAIK,SAAtC;;;;;;;;MAQIC,WAAWhD,MAAMG,MAAN,CAAalC,OAAb,CAAqB,qBAArB,CAAjB;MACImE,YAAJ,CAAiB,iBAAjB,EAAoC,IAApC;MACIH,KAAJ,CAAUgB,QAAV,GAAqB,UAArB;MACIhB,KAAJ,CAAUiB,IAAV,GAAiB,SAAjB;WACSf,WAAT,CAAqBO,GAArB;SACOS,iBAAP,CAAyBT,GAAzB;;;SAGOU,qBAAP,CAA6B,YAAM;aACxBC,WAAT,CAAqBX,GAArB;oBACgBtC,MAAhB;WACOkD,QAAP,CAAgBtH,KAAhB;;GAHF;;;AC/HF;;;;;;;;AAQA,SAASuH,QAAT,CAAkBC,OAAlB,EAA2BlG,MAA3B,EAAmC;YAE/B,CAACC,MAAMC,OAAN,CAAcF,MAAd,CADH,EAEE,oFAFF;;MAKMW,UAAUuF,QAAQvF,OAAR,CAAgB,YAAhB,CAAhB;MACI,CAACA,OAAL,EAAc,OAAO,IAAP;;MAER/C,MAAM+C,QAAQW,YAAR,CAAqB,UAArB,CAAZ;MACI,CAAC1D,GAAL,EAAU,OAAO,IAAP;;MAEF4D,KAZyB,GAYfxB,MAZe,CAYzBwB,KAZyB;MAazBtD,QAbyB,GAaZsD,KAbY,CAazBtD,QAbyB;;MAc3BmC,OAAOnC,SAASiI,OAAT,CAAiBvI,GAAjB,CAAb;SACOyC,QAAQ,IAAf;;;ACxBF;;;;;;;;AAQA,SAAS+F,YAAT,CAAsB1E,KAAtB,EAA2C;MAAd7D,GAAc,uEAARC,MAAQ;;MACnCG,KAAKN,YAAY+D,MAAM9D,GAAlB,EAAuBC,GAAvB,CAAX;MACIoF,QAAQ,CAAZ;;;;;MAKMoD,QAAQC,MAAMC,IAAN,CACZtI,GAAGqG,gBAAH,CAAoB,+CAApB,CADY,CAAd;;;;;;;yBAImB+B,KAAnB,8HAA0B;UAAfG,IAAe;;UAClBnG,OAAOmG,KAAK3E,UAAL,CAAgB,CAAhB,CAAb;UACM4E,YAAYpG,KAAKc,WAAL,CAAiBF,MAAnC;UACIyF,cAAcD,SAAlB;;UAEID,KAAKpF,YAAL,CAAkB,mBAAlB,CAAJ,EAA4C;sBAC5BhC,SAASoH,KAAKlF,YAAL,CAAkB,mBAAlB,CAAT,EAAiD,EAAjD,CAAd;;;UAGI4B,MAAMD,QAAQyD,WAApB;;UAEIhF,MAAMnB,MAAN,IAAgB2C,GAApB,EAAyB;YACjB3C,SAASoG,KAAKC,GAAL,CAASH,SAAT,EAAoBE,KAAKE,GAAL,CAAS,CAAT,EAAYnF,MAAMnB,MAAN,GAAe0C,KAA3B,CAApB,CAAf;eACO,EAAE5C,UAAF,EAAQE,cAAR,EAAP;;;cAGM2C,GAAR;;;;;;;;;;;;;;;;;SAGK,IAAP;;;AChCF;;;;;;;;AAQA,SAAS4D,SAAT,CAAmBhE,MAAnB,EAA2B9C,MAA3B,EAAmC;YAE/B,CAACC,MAAMC,OAAN,CAAcF,MAAd,CADH,EAEE,oFAFF;;MAKM/B,KAAK6E,OAAOiE,UAAP,IAAqBjE,OAAOkE,cAAvC;MACI,CAAC/I,EAAL,EAAS,OAAO,IAAP;;MAEHH,SAAS0C,UAAUvC,EAAV,CAAf;;;;MAKE6E,kBAAkBhF,OAAOmJ,KAAzB,IACCnJ,OAAOoJ,WAAP,IAAsBpE,kBAAkBhF,OAAOoJ,WAFlD,EAGE;aACS;kBACKpE,OAAOkE,cADZ;oBAEOlE,OAAOqE,WAFd;iBAGIrE,OAAOsE,YAHX;mBAIMtE,OAAOuE;KAJtB;;;gBAcEvE,MA/B6B;MA0B/BiE,UA1B+B,WA0B/BA,UA1B+B;MA2B/BO,YA3B+B,WA2B/BA,YA3B+B;MA4B/BC,SA5B+B,WA4B/BA,SA5B+B;MA6B/BC,WA7B+B,WA6B/BA,WA7B+B;MA8B/BlE,WA9B+B,WA8B/BA,WA9B+B;MAgCzB9B,KAhCyB,GAgCfxB,MAhCe,CAgCzBwB,KAhCyB;;MAiC3BiG,SAAS5H,UAAUkH,UAAV,EAAsBO,YAAtB,EAAoCtH,MAApC,CAAf;MACM0H,QAAQpE,cAAcmE,MAAd,GAAuB5H,UAAU0H,SAAV,EAAqBC,WAArB,EAAkCxH,MAAlC,CAArC;MACI,CAACyH,MAAD,IAAW,CAACC,KAAhB,EAAuB,OAAO,IAAP;;;;;MAKnBnC,SAASoC,OAAb,EAAsB;QACdC,YAAYxB,aAAaqB,MAAb,CAAlB;QACMI,WAAWzB,aAAasB,KAAb,CAAjB;;aAES;kBACKE,UAAUvH,IADf;oBAEOuH,UAAUrH,MAFjB;iBAGIsH,SAASxH,IAHb;mBAIMwH,SAAStH;KAJxB;;;MAQMrC,QApDyB,GAoDZsD,KApDY,CAoDzBtD,QApDyB;;MAqD3BQ,QAAQR,SAAS0C,WAAT,CAAqB;kBAAA;;GAArB,CAAd;;SAKOlC,KAAP;;;ACnEF;;;;;;;;AAQA,SAASoJ,aAAT,CAAuBpF,KAAvB,EAA8B1C,MAA9B,EAAsC;YAElC,CAACC,MAAMC,OAAN,CAAcF,MAAd,CADH,EAEE,oFAFF;;MAKI0C,MAAMqF,WAAV,EAAuB;YACbrF,MAAMqF,WAAd;;;eAGuBrF,KAVW;MAU5BsF,CAV4B,UAU5BA,CAV4B;MAUzBC,CAVyB,UAUzBA,CAVyB;MAUtBpF,MAVsB,UAUtBA,MAVsB;;MAWhCmF,KAAK,IAAL,IAAaC,KAAK,IAAtB,EAA4B,OAAO,IAAP;;MAEpBzG,KAb4B,GAalBxB,MAbkB,CAa5BwB,KAb4B;MAc5BtD,QAd4B,GAcfsD,KAde,CAc5BtD,QAd4B;;MAe9BmC,OAAO4F,SAASpD,MAAT,EAAiB7C,MAAjB,CAAb;MACI,CAACK,IAAL,EAAW,OAAO,IAAP;;;;;MAKPL,OAAOkI,KAAP,CAAa,QAAb,EAAuB7H,IAAvB,CAAJ,EAAkC;QAC1B8H,OAAOtF,OAAOuF,qBAAP,EAAb;QACMC,aACJhI,KAAKf,MAAL,IAAe,QAAf,GACI0I,IAAIG,KAAKvC,IAAT,GAAgBuC,KAAKvC,IAAL,GAAYuC,KAAKG,KAAjB,GAAyBN,CAD7C,GAEIC,IAAIE,KAAKI,GAAT,GAAeJ,KAAKI,GAAL,GAAWJ,KAAKK,MAAhB,GAAyBP,CAH9C;;QAKMzB,OAAOnG,KAAKoI,YAAL,EAAb;QACM/J,SAAQR,SAAS0C,WAAT,EAAd;;QAEIyH,UAAJ,EAAgB;UACRK,eAAexK,SAASyK,eAAT,CAAyBnC,KAAK5I,GAA9B,CAArB;;UAEI8K,YAAJ,EAAkB;eACThK,OAAMkK,eAAN,CAAsBF,YAAtB,CAAP;;;;QAIEG,WAAW3K,SAAS4K,WAAT,CAAqBtC,KAAK5I,GAA1B,CAAjB;WACOiL,WAAWnK,OAAMqK,iBAAN,CAAwBF,QAAxB,CAAX,GAA+C,IAAtD;;;;MAII/K,SAAS0C,UAAUqC,MAAV,CAAf;MACIC,eAAJ;;;MAGIhF,OAAOI,QAAP,CAAgB8K,mBAApB,EAAyC;aAC9BlL,OAAOI,QAAP,CAAgB8K,mBAAhB,CAAoChB,CAApC,EAAuCC,CAAvC,CAAT;GADF,MAEO,IAAInK,OAAOI,QAAP,CAAgB+K,sBAApB,EAA4C;QAC3CtD,WAAW7H,OAAOI,QAAP,CAAgB+K,sBAAhB,CAAuCjB,CAAvC,EAA0CC,CAA1C,CAAjB;aACSnK,OAAOI,QAAP,CAAgB0C,WAAhB,EAAT;WACOE,QAAP,CAAgB6E,SAASuD,UAAzB,EAAqCvD,SAASpF,MAA9C;WACOQ,MAAP,CAAc4E,SAASuD,UAAvB,EAAmCvD,SAASpF,MAA5C;GAJK,MAKA,IAAIzC,OAAOI,QAAP,CAAgBM,IAAhB,CAAqBC,eAAzB,EAA0C;;;aAGtCX,OAAOI,QAAP,CAAgBM,IAAhB,CAAqBC,eAArB,EAAT;;QAEI;aACK0K,WAAP,CAAmBnB,CAAnB,EAAsBC,CAAtB;KADF,CAEE,OAAOmB,KAAP,EAAc;;;aAGP,IAAP;;;;;MAKE1K,QAAQoI,UAAUhE,MAAV,EAAkB9C,MAAlB,CAAd;MACI,CAACtB,KAAL,EAAY,OAAO,IAAP;;SAELA,KAAP;;;ACpFF;;;;;;IAMQ4D,aAAqC5E,eAArC4E;IAAUC,SAA2B7E,eAA3B6E;IAAM8G,OAAqB3L,eAArB2L;IAAMC,OAAe5L,eAAf4L;IAAM9G,SAAS9E,eAAT8E;;;;;;;;AAQpC,IAAM+G,mBAAmB,kCAAzB;;;;;;;;;AASA,SAASC,gBAAT,CAA0B9G,KAA1B,EAAiC;;;;MAI3B,CAAC6C,KAAD,IAAU7C,MAAMqF,WAApB,EAAiC;YACvBrF,MAAMqF,WAAd;;;MAGI0B,WAAW/G,MAAMgH,YAAN,IAAsBhH,MAAM2C,aAA7C;MACIrC,WAAW2G,QAAQF,QAAR,EAAkBnH,UAAlB,CAAf;MACIjC,OAAOsJ,QAAQF,QAAR,EAAkBJ,IAAlB,CAAX;MACMO,OAAOD,QAAQF,QAAR,EAAkBlH,MAAlB,CAAb;MACMsH,OAAOF,QAAQF,QAAR,EAAkBH,IAAlB,CAAb;MACI9C,OAAOmD,QAAQF,QAAR,EAAkBjH,MAAlB,CAAX;MACIsH,cAAJ;;;;MAII,CAAC9G,QAAD,IAAa4G,IAAb,IAAqB,CAACA,KAAKG,OAAL,CAAa,wBAAb,CAA1B,EAAkE;QAC1D/K,UAAUuK,iBAAiBtK,IAAjB,CAAsB2K,IAAtB,CAAhB;;iCACwB5K,OAFwC;QAEzDgL,IAFyD;QAEnDzG,OAFmD;;;QAG5DA,OAAJ,EAAaP,WAAWO,OAAX;;;;;MAKXiD,IAAJ,EAAU;QACFyD,gBAAgBC,iBAAiB1D,IAAjB,CAAtB;;QAEIyD,cAAc3H,UAAd,CAAJ,EAA6BU,WAAWiH,cAAc3H,UAAd,CAAX;QACzB2H,cAAcZ,IAAd,CAAJ,EAAyBhJ,OAAO4J,cAAcZ,IAAd,CAAP;QACrBY,cAAczH,MAAd,CAAJ,EAAyBgE,OAAOyD,cAAczH,MAAd,CAAP;;;;MAIvBQ,QAAJ,EAAcA,WAAWQ,OAAO2G,eAAP,CAAuBnH,QAAvB,CAAX;MACV3C,IAAJ,EAAUA,OAAOmD,OAAO2G,eAAP,CAAuB9J,IAAvB,CAAP;;;;MAIN;;QAEEoJ,SAASW,KAAT,IAAkBX,SAASW,KAAT,CAAenJ,MAArC,EAA6C;cACnCqF,MAAMC,IAAN,CAAWkD,SAASW,KAApB,EACLC,GADK,CACD;eAASC,KAAKC,IAAL,IAAa,MAAb,GAAsBD,KAAKE,SAAL,EAAtB,GAAyC,IAAlD;OADC,EAELC,MAFK,CAEE;eAAUC,MAAV;OAFF,CAAR;KADF,MAIO,IAAIjB,SAASK,KAAT,IAAkBL,SAASK,KAAT,CAAe7I,MAArC,EAA6C;cAC1CqF,MAAMC,IAAN,CAAWkD,SAASK,KAApB,CAAR;;GAPJ,CASE,OAAOa,GAAP,EAAY;QACRlB,SAASK,KAAT,IAAkBL,SAASK,KAAT,CAAe7I,MAArC,EAA6C;cACnCqF,MAAMC,IAAN,CAAWkD,SAASK,KAApB,CAAR;;;;;MAKEc,OAAO,EAAEd,YAAF,EAAS9G,kBAAT,EAAmB4G,UAAnB,EAAyBvJ,UAAzB,EAA+BwJ,UAA/B,EAAqCrD,UAArC,EAAb;OACKqE,IAAL,GAAYC,gBAAgBF,IAAhB,CAAZ;SACOA,IAAP;;;;;;;;;;;AAWF,SAASV,gBAAT,CAA0B1D,IAA1B,EAAgC;MACxBuE,SAAS,oBAAf;;MAEIvE,KAAKwE,SAAL,CAAe,CAAf,EAAkBD,OAAO9J,MAAzB,KAAoC8J,MAAxC,EAAgD;WACvC,EAAEvI,MAAMgE,IAAR,EAAP;;;;;MAKE;WACKyE,KAAKnM,KAAL,CAAW0H,KAAKwE,SAAL,CAAeD,OAAO9J,MAAtB,CAAX,CAAP;GADF,CAEE,OAAO0J,GAAP,EAAY;UACN,IAAIvM,KAAJ,CAAU,+CAAV,CAAN;;;;;;;;;;;AAWJ,SAAS0M,eAAT,CAAyBF,IAAzB,EAA+B;MACzBA,KAAK5H,QAAT,EAAmB,OAAO,UAAP;MACf4H,KAAKvK,IAAT,EAAe,OAAO,MAAP;;;;;;MAMXuK,KAAKf,IAAL,IAAae,KAAKhB,IAAtB,EAA4B,OAAO,MAAP;MACxBgB,KAAKf,IAAL,IAAae,KAAKpE,IAAtB,EAA4B,OAAO,MAAP;;MAExBoE,KAAKd,KAAL,IAAcc,KAAKd,KAAL,CAAW7I,MAA7B,EAAqC,OAAO,OAAP;MACjC2J,KAAKhB,IAAT,EAAe,OAAO,MAAP;MACXgB,KAAKpE,IAAT,EAAe,OAAO,MAAP;SACR,SAAP;;;;;;;;;;;;AAYF,SAASmD,OAAT,CAAiBF,QAAjB,EAA2BoB,IAA3B,EAAiC;MAC3B,CAACpB,SAASyB,KAAV,IAAmB,CAACzB,SAASyB,KAAT,CAAejK,MAAvC,EAA+C;;;WAGtC4J,QAAQrI,MAAR,GAAeiH,SAAS0B,OAAT,CAAiB,MAAjB,KAA4B,IAA3C,GAAkD,IAAzD;;;;MAIID,QAAQ5E,MAAMC,IAAN,CAAWkD,SAASyB,KAApB,CAAd;;SAEOA,MAAMnB,OAAN,CAAcc,IAAd,MAAwB,CAAC,CAAzB,GAA6BpB,SAAS0B,OAAT,CAAiBN,IAAjB,KAA0B,IAAvD,GAA8D,IAArE;;;ACzJF;;;;;;IAMQrI,SAAS9E,eAAT8E;;;;;;;;;;;;;AAaR,SAAS4I,gBAAT,CAA0B1I,KAA1B,EAAiCmI,IAAjC,EAAuCQ,OAAvC,EAAgD;MACxCC,OAAO5N,eAAemN,KAAKU,WAAL,EAAf,CAAb;;MAEI,CAACD,IAAL,EAAW;UACH,IAAIlN,KAAJ,wCAA+CkN,IAA/C,QAAN;;;MAGE5I,MAAMqF,WAAV,EAAuB;YACbrF,MAAMqF,WAAd;;;MAGI0B,WAAW/G,MAAMgH,YAAN,IAAsBhH,MAAM2C,aAA7C;;MAEI;aACOC,OAAT,CAAiBgG,IAAjB,EAAuBD,OAAvB;;;aAGS/F,OAAT,CAAiB,MAAjB,EAAyBmE,SAAS0B,OAAT,CAAiB,MAAjB,CAAzB;GAJF,CAKE,OAAOR,GAAP,EAAY;QACNI,SAAS,oBAAf;QACMvE,OAAOiD,SAAS0B,OAAT,CAAiB3I,MAAjB,CAAb;QACIgJ,MAAM,EAAV;;;QAGIhF,KAAKwE,SAAL,CAAe,CAAf,EAAkBD,OAAO9J,MAAzB,MAAqC8J,MAAzC,EAAiD;UAC3C;cACIE,KAAKnM,KAAL,CAAW0H,KAAKwE,SAAL,CAAeD,OAAO9J,MAAtB,CAAX,CAAN;OADF,CAEE,OAAOwK,CAAP,EAAU;cACJ,IAAIrN,KAAJ,CACJ,wDADI,CAAN;;KAJJ,MAQO;;UAEDoE,MAAJ,IAAYgE,IAAZ;;;QAGE8E,IAAJ,IAAYD,OAAZ;QACMtM,cAAYgM,MAAZ,GAAqBE,KAAK5L,SAAL,CAAemM,GAAf,CAA3B;aACSlG,OAAT,CAAiB9C,MAAjB,EAAuBzD,MAAvB;;;;AC5CJ;;;;;;AAMA,IAAM2M,QAAQC,MAAM,aAAN,CAAd;;;;;;;;;AASA,SAASC,WAAT,GAAmC;MAC7BC,uBAAuB,IAA3B;MACIC,cAAc,KAAlB;;;;;;;;;;WAUSC,aAAT,CAAuBrJ,KAAvB,EAA8B1C,MAA9B,EAAsCgM,IAAtC,EAA4C;QAClCxK,KADkC,GACxBxB,MADwB,CAClCwB,KADkC;;QAEpCyK,cAAc,CAAC,CAACvJ,MAAMqF,WAA5B;;;;;QAKIkE,WAAJ,EAAiB;YACTzG,cAAN;aACO0G,UAAP,CAAkBxJ,MAAMkI,IAAxB;aACOoB,MAAP;;;;;;gCAKoBtJ,MAAMyJ,eAAN,EAfoB;;QAenCC,WAfmC;;QAgBtC,CAACA,WAAL,EAAkB,OAAOJ,MAAP;;UAEZ,eAAN,EAAuB,EAAEtJ,YAAF,EAAvB;;UAEM8C,cAAN;;QAEQtH,QAtBkC,GAsBVsD,KAtBU,CAsBlCtD,QAtBkC;QAsBxBI,SAtBwB,GAsBVkD,KAtBU,CAsBxBlD,SAtBwB;;QAuBpCI,QAAQoI,UAAUsF,WAAV,EAAuBpM,MAAvB,CAAd;;YAEQ0C,MAAM2J,SAAd;WACO,cAAL;WACK,aAAL;WACK,eAAL;WACK,uBAAL;WACK,sBAAL;;iBACSC,aAAP,CAAqB5N,KAArB;;;;WAIG,oBAAL;;iBACS6N,yBAAP,CAAiC7N,KAAjC;;;;WAIG,mBAAL;;iBACS8N,wBAAP,CAAgC9N,KAAhC;;;;WAIG,wBAAL;WACK,wBAAL;;iBACS+N,yBAAP,CAAiC/N,KAAjC;;;;WAIG,uBAAL;WACK,uBAAL;;iBACSgO,wBAAP,CAAgChO,KAAhC;;;;WAIG,iBAAL;WACK,iBAAL;;cACQiO,gBAAgBzO,SAASyO,aAAT,CACpBrO,UAAU2E,KAAV,CAAgB2J,IADI,EAEpB5M,MAFoB,CAAtB;;cAKI2M,aAAJ,EAAmB;mBACVE,qBAAP;WADF,MAEO;mBACEC,iBAAP,CAAyBpO,KAAzB;;;;;;WAMC,gBAAL;WACK,uBAAL;WACK,YAAL;;;;;;cAKQ8H,OACJ9D,MAAMkI,IAAN,IAAc,IAAd,GACIlI,MAAMgH,YAAN,CAAmByB,OAAnB,CAA2B,YAA3B,CADJ,GAEIzI,MAAMkI,IAHZ;;cAKIpE,QAAQ,IAAZ,EAAkB;;iBAEXuG,iBAAP,CAAyBrO,KAAzB,EAAgC8H,IAAhC,EAAsClI,UAAU0O,KAAhD;;;;cAII1O,UAAU0O,KAAV,IAAmBxL,MAAMtD,QAAN,IAAkB8B,OAAOwB,KAAP,CAAatD,QAAtD,EAAgE;mBACvDU,MAAP,CAAc,EAAEoO,OAAO,IAAT,EAAd;;;;;;;;;;;;;;;;;;WAkBCC,MAAT,CAAgBvK,KAAhB,EAAuB1C,MAAvB,EAA+BgM,IAA/B,EAAqC;UAC7B,QAAN,EAAgB,EAAEtJ,YAAF,EAAhB;WACOwK,IAAP;;;;;;;;;;;;WAYOC,OAAT,CAAiBzK,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;QAChChM,OAAOoN,QAAX,EAAqB,OAAOpB,MAAP;;QAEbxK,KAH4B,GAGlBxB,MAHkB,CAG5BwB,KAH4B;QAI5BtD,QAJ4B,GAIfsD,KAJe,CAI5BtD,QAJ4B;;QAK9BmC,OAAO4F,SAASvD,MAAMG,MAAf,EAAuB7C,MAAvB,CAAb;QACI,CAACK,IAAL,EAAW,OAAO2L,MAAP;;UAEL,SAAN,EAAiB,EAAEtJ,YAAF,EAAjB;;QAEM2K,YAAYnP,SAASoP,YAAT,CAAsBjN,KAAKzC,GAA3B,CAAlB;QACM2P,SACJlN,SAASL,OAAOuN,MAAP,CAAclN,IAAd,KAAuBgN,UAAUG,IAAV,CAAe;aAAKxN,OAAOuN,MAAP,CAAcE,CAAd,CAAL;KAAf,CAAhC,CADF;;QAGIF,MAAJ,EAAY;;;;;aAKH7F,KAAP,GAAekB,eAAf,CAA+BvI,IAA/B;;;;;;;;;;;;;;WAcKqN,MAAT,CAAgBhL,KAAhB,EAAuB1C,MAAvB,EAA+BgM,IAA/B,EAAqC;UAC7B,QAAN,EAAgB,EAAEtJ,YAAF,EAAhB;kBACcA,KAAd,EAAqB1C,MAArB;;;;;;;;;;;;WAYO2N,KAAT,CAAejL,KAAf,EAAsB1C,MAAtB,EAA8BgM,IAA9B,EAAoC;UAC5B,OAAN,EAAe,EAAEtJ,YAAF,EAAf;;;;kBAIcA,KAAd,EAAqB1C,MAArB,EAA6B,YAAM;;;UAGzBwB,KAHyB,GAGfxB,MAHe,CAGzBwB,KAHyB;UAIzBoM,QAJyB,GAIUpM,KAJV,CAIzBoM,QAJyB;UAIfC,SAJe,GAIUrM,KAJV,CAIfqM,SAJe;UAIJvP,SAJI,GAIUkD,KAJV,CAIJlD,SAJI;UAKzBgF,WALyB,GAKThF,SALS,CAKzBgF,WALyB;;UAM3BwK,cAAcF,YAAY5N,OAAOuN,MAAP,CAAcK,QAAd,CAAZ,IAAuCtK,WAA3D;UACMyK,eAAeF,aAAa7N,OAAOuN,MAAP,CAAcM,SAAd,CAAb,IAAyCvK,WAA9D;;UAEIwK,WAAJ,EAAiB;eACRE,eAAP,CAAuBJ,SAAShQ,GAAhC;OADF,MAEO,IAAImQ,YAAJ,EAAkB;eAChBC,eAAP,CAAuBH,UAAUjQ,GAAjC;OADK,MAEA;eACEqQ,MAAP;;KAdJ;;;;;;;;;;;;;WA6BOC,SAAT,CAAmBxL,KAAnB,EAA0B1C,MAA1B,EAAkCgM,IAAlC,EAAwC;UAChC,WAAN,EAAmB,EAAEtJ,YAAF,EAAnB;2BACuB,IAAvB;;;;;;;;;;;;WAYOyL,WAAT,CAAqBzL,KAArB,EAA4B1C,MAA5B,EAAoCgM,IAApC,EAA0C;UAClC,aAAN,EAAqB,EAAEtJ,YAAF,EAArB;;2BAEuB,IAAvB;;QAEQlB,KALgC,GAKtBxB,MALsB,CAKhCwB,KALgC;QAMhCtD,QANgC,GAMnBsD,KANmB,CAMhCtD,QANgC;;QAOlCmC,OAAO4F,SAASvD,MAAMG,MAAf,EAAuB7C,MAAvB,CAAb;QACMqN,YAAYnP,SAASoP,YAAT,CAAsBjN,KAAKzC,GAA3B,CAAlB;QACM2P,SACJlN,SAASL,OAAOuN,MAAP,CAAclN,IAAd,KAAuBgN,UAAUG,IAAV,CAAe;aAAKxN,OAAOuN,MAAP,CAAcE,CAAd,CAAL;KAAf,CAAhC,CADF;QAEMW,wBAAwB5M,MAAM6M,MAAN,CAAab,IAAb,CAC5B;aAASc,MAAM1Q,GAAN,KAAcyC,KAAKzC,GAA5B;KAD4B,CAA9B;;;QAKI2P,UAAU,CAACa,qBAAf,EAAsC;aAC7BG,iBAAP,CAAyBlO,IAAzB;;;QAGI2C,WAAWhD,OAAOwB,KAAP,CAAawB,QAA9B;QACMO,UAAUC,OAAOC,aAAP,CAAqBT,QAArB,CAAhB;qBACiBN,KAAjB,EAAwB,UAAxB,EAAoCa,OAApC;;;;;;;;;;;;WAYOiL,MAAT,CAAgB9L,KAAhB,EAAuB1C,MAAvB,EAA+BgM,IAA/B,EAAqC;QAC3BxK,KAD2B,GACjBxB,MADiB,CAC3BwB,KAD2B;QAE3BtD,QAF2B,GAEHsD,KAFG,CAE3BtD,QAF2B;QAEjBI,SAFiB,GAEHkD,KAFG,CAEjBlD,SAFiB;;QAG7BR,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;QACIA,SAASiF,cAAcpF,KAAd,EAAqB1C,MAArB,CAAb;QACI,CAAC6C,MAAL,EAAa,OAAOmJ,MAAP;;UAEP,QAAN,EAAgB,EAAEtJ,YAAF,EAAhB;;QAEM+G,WAAWD,iBAAiB9G,KAAjB,CAAjB;QACQmI,IAV2B,GAUFpB,QAVE,CAU3BoB,IAV2B;QAUrB7H,QAVqB,GAUFyG,QAVE,CAUrBzG,QAVqB;QAUXwD,IAVW,GAUFiD,QAVE,CAUXjD,IAVW;;;WAY5BkB,KAAP;;;;QAKEmE,wBACAvN,UAAU4E,GAAV,CAActF,GAAd,IAAqBiF,OAAOK,GAAP,CAAWtF,GADhC,IAEAU,UAAU4E,GAAV,CAAc3C,MAAd,GAAuBsC,OAAOK,GAAP,CAAW3C,MAHpC,EAIE;eACSsC,OAAO4L,WAAP,CACPnQ,UAAU2E,KAAV,CAAgBrF,GAAhB,IAAuBU,UAAU4E,GAAV,CAActF,GAArC,GACI,IAAIU,UAAU4E,GAAV,CAAc3C,MAAlB,GAA2BjC,UAAU2E,KAAV,CAAgB1C,MAD/C,GAEI,IAAIjC,UAAU4E,GAAV,CAAc3C,MAHf,CAAT;;;QAOEsL,oBAAJ,EAA0B;aACjBoC,MAAP;;;WAGKrP,MAAP,CAAciE,MAAd;;QAEIgI,QAAQ,MAAR,IAAkBA,QAAQ,MAA9B,EAAsC;oBACjBhI,MADiB;UAC5B4E,MAD4B,WAC5BA,MAD4B;;UAEhCkF,gBAAgBzO,SAASyO,aAAT,CAAuBlF,OAAO7J,GAA9B,EAAmCoC,MAAnC,CAApB;;UAEI2M,aAAJ,EAAmB;YACb+B,IAAIxQ,SAASiI,OAAT,CAAiBsB,OAAO7J,GAAxB,CAAR;;eAEO+O,aAAP,EAAsB;cAChBzO,SAAS4K,WAAT,CAAqB4F,EAAE9Q,GAAvB,CAAJ;cACI,CAAC8Q,CAAL,EAAQ;0BACQxQ,SAASyO,aAAT,CAAuB+B,EAAE9Q,GAAzB,EAA8BoC,MAA9B,CAAhB;;;YAGE0O,CAAJ,EAAO1O,OAAO+I,iBAAP,CAAyB2F,CAAzB;;;UAGLlI,IAAJ,EAAU;aACHmI,KAAL,CAAW,IAAX,EAAiB7K,OAAjB,CAAyB,UAAC8K,IAAD,EAAO3M,CAAP,EAAa;cAChCA,IAAI,CAAR,EAAWjC,OAAO6O,UAAP;iBACJ3C,UAAP,CAAkB0C,IAAlB;SAFF;;;;QAOA/D,QAAQ,UAAZ,EAAwB;aACfiE,cAAP,CAAsB9L,QAAtB;;;;;;;QAOIuE,YAAYrJ,SAASiI,OAAT,CAAiBtD,OAAO6E,KAAP,CAAa9J,GAA9B,CAAlB;QACMK,KAAKN,YAAY4J,SAAZ,EAAuBzJ,MAAvB,CAAX;;QAEIG,EAAJ,EAAQ;SACH8Q,aAAH,CACE,IAAIC,UAAJ,CAAe,SAAf,EAA0B;cAClBlR,MADkB;iBAEf,IAFe;oBAGZ;OAHd,CADF;;;;;;;;;;;;;;WAoBKmR,OAAT,CAAiBvM,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;UAC9B,SAAN,EAAiB,EAAEtJ,YAAF,EAAjB;;;;;;QAMIoJ,WAAJ,EAAiB;aACRoD,QAAP,GAAkBxH,KAAlB;KADF,MAEO;aACEA,KAAP;;;;;;;;;;;;;;WAcKyH,OAAT,CAAiBzM,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;QAC9BlO,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;QACQrB,KAF4B,GAElBxB,MAFkB,CAE5BwB,KAF4B;;;;QAK9BsB,SAAShF,OAAOiF,YAAP,EAAf;QACQgE,UAN4B,GAMbjE,MANa,CAM5BiE,UAN4B;;QAO9BrF,QAAQ7B,UAAUkH,UAAV,EAAsB,CAAtB,EAAyB/G,MAAzB,CAAd;QACI,CAAC0B,KAAL,EAAY,OAAOsK,MAAP;;;QAGJ9N,QAX4B,GAWJsD,KAXI,CAW5BtD,QAX4B;QAWlBI,SAXkB,GAWJkD,KAXI,CAWlBlD,SAXkB;;QAY9B+B,OAAOnC,SAASkR,aAAT,CAAuB1N,MAAM9D,GAA7B,CAAb;QACM0Q,QAAQpQ,SAASmR,eAAT,CAAyBhP,KAAKzC,GAA9B,CAAd;QACM0R,SAASjP,KAAKkP,SAAL,EAAf;QACMC,WAAWlB,MAAMmB,WAAN,EAAjB;QACMC,WAAWJ,OAAOK,IAAP,EAAjB;QACI1M,QAAQ,CAAZ;QACIC,MAAM,CAAV;;QAEM0M,OACJN,OAAOO,IAAP,CAAY,aAAK;cACP3M,GAAR;aACOc,EAAEwC,IAAF,CAAOvF,MAAd;UACIiC,MAAMxB,MAAMnB,MAAhB,EAAwB,OAAO,IAAP;KAH1B,KAIMmP,QALR;;;QAQQlJ,IA5B4B,GA4BnBoJ,IA5BmB,CA4B5BpJ,IA5B4B;QA6B9BrF,WA7B8B,GA6Bd4F,UA7Bc,CA6B9B5F,WA7B8B;;QA8B9B2O,aAAazP,QAAQmP,QAA3B;QACMO,aAAaH,QAAQF,QAA3B;QACMM,WAAW7O,YAAY8O,MAAZ,CAAmB9O,YAAYF,MAAZ,GAAqB,CAAxC,CAAjB;;;;;QAKI6O,cAAcC,UAAd,IAA4BC,YAAY,IAA5C,EAAkD;oBAClC7O,YAAYiD,KAAZ,CAAkB,CAAlB,EAAqB,CAAC,CAAtB,CAAd;;;;QAIEjD,eAAeqF,IAAnB,EAAyB,OAAOwF,MAAP;;UAEnB,SAAN,EAAiB,EAAEtJ,YAAF,EAAjB;;;QAGMwN,QAAQ/O,YAAYF,MAAZ,GAAqBuF,KAAKvF,MAAxC;QACMkP,YAAY7R,UAAU8R,SAAV,GAAsB3B,WAAtB,CAAkCyB,KAAlC,CAAlB;QACIG,SAAS/R,UACVgS,YADU,CACG5O,MAAM9D,GADT,EACcqF,KADd,EAEVsN,WAFU,CAEE7O,MAAM9D,GAFR,EAEasF,GAFb,CAAb;;aAIShF,SAASsS,YAAT,CAAsBH,MAAtB,CAAT;;;WAGOtD,iBAAP,CAAyBsD,MAAzB,EAAiClP,WAAjC,EAA8CyO,KAAK5C,KAAnD,EAA0DpO,MAA1D,CAAiEuR,SAAjE;;;;;;;;;;;;WAYOM,SAAT,CAAmB/N,KAAnB,EAA0B1C,MAA1B,EAAkCgM,IAAlC,EAAwC;UAChC,WAAN,EAAmB,EAAEtJ,YAAF,EAAnB;;QAEQlB,KAH8B,GAGpBxB,MAHoB,CAG9BwB,KAH8B;QAI9BtD,QAJ8B,GAINsD,KAJM,CAI9BtD,QAJ8B;QAIpBI,SAJoB,GAINkD,KAJM,CAIpBlD,SAJoB;;QAKhCqO,gBAAgBzO,SAASyO,aAAT,CAAuBrO,UAAU2E,KAAV,CAAgB2J,IAAvC,EAA6C5M,MAA7C,CAAtB;;;;;QAKI0Q,QAAQC,YAAR,CAAqBjO,KAArB,KAA+B,CAACkO,MAApC,EAA4C;aACnCjE,gBACH3M,OAAO6M,qBAAP,EADG,GAEH7M,OAAO6O,UAAP,EAFJ;;;QAKE6B,QAAQG,gBAAR,CAAyBnO,KAAzB,KAAmC,CAACkO,MAAxC,EAAgD;aACvC5Q,OAAO8Q,kBAAP,EAAP;;;QAGEJ,QAAQK,eAAR,CAAwBrO,KAAxB,KAAkC,CAACkO,MAAvC,EAA+C;aACtC5Q,OAAOgR,iBAAP,EAAP;;;QAGEN,QAAQO,oBAAR,CAA6BvO,KAA7B,CAAJ,EAAyC;aAChC1C,OAAOkR,kBAAP,EAAP;;;QAGER,QAAQS,mBAAR,CAA4BzO,KAA5B,CAAJ,EAAwC;aAC/B1C,OAAOoR,iBAAP,EAAP;;;QAGEV,QAAQW,oBAAR,CAA6B3O,KAA7B,CAAJ,EAAyC;aAChC1C,OAAOsR,kBAAP,EAAP;;;QAGEZ,QAAQa,mBAAR,CAA4B7O,KAA5B,CAAJ,EAAwC;aAC/B1C,OAAOwR,iBAAP,EAAP;;;QAGEd,QAAQe,MAAR,CAAe/O,KAAf,CAAJ,EAA2B;aAClB1C,OAAO0R,IAAP,EAAP;;;QAGEhB,QAAQiB,MAAR,CAAejP,KAAf,CAAJ,EAA2B;aAClB1C,OAAO4R,IAAP,EAAP;;;;;;QAMElB,QAAQmB,kBAAR,CAA2BnP,KAA3B,CAAJ,EAAuC;YAC/B8C,cAAN;aACOxF,OAAO8R,kBAAP,EAAP;;;QAGEpB,QAAQqB,iBAAR,CAA0BrP,KAA1B,CAAJ,EAAsC;YAC9B8C,cAAN;aACOxF,OAAOgS,gBAAP,EAAP;;;QAGEtB,QAAQuB,oBAAR,CAA6BvP,KAA7B,CAAJ,EAAyC;YACjC8C,cAAN;aACOxF,OAAOkS,uBAAP,EAAP;;;QAGExB,QAAQyB,mBAAR,CAA4BzP,KAA5B,CAAJ,EAAwC;YAChC8C,cAAN;aACOxF,OAAOoS,qBAAP,EAAP;;;;;;QAME1B,QAAQ2B,cAAR,CAAuB3P,KAAvB,CAAJ,EAAmC;YAC3B8C,cAAN;;UAEI,CAAClH,UAAUgF,WAAf,EAA4B;eACnBtD,OAAOsS,WAAP,EAAP;;;aAGKtS,OAAOuS,YAAP,EAAP;;;QAGE7B,QAAQ8B,aAAR,CAAsB9P,KAAtB,CAAJ,EAAkC;YAC1B8C,cAAN;;UAEI,CAAClH,UAAUgF,WAAf,EAA4B;eACnBtD,OAAOoQ,SAAP,EAAP;;;aAGKpQ,OAAOyO,WAAP,EAAP;;;QAGEiC,QAAQ+B,kBAAR,CAA2B/P,KAA3B,CAAJ,EAAuC;YAC/B8C,cAAN;aACOxF,OAAO0S,gBAAP,EAAP;;;QAGEhC,QAAQiC,iBAAR,CAA0BjQ,KAA1B,CAAJ,EAAsC;YAC9B8C,cAAN;aACOxF,OAAO4S,eAAP,EAAP;;;QAGElC,QAAQmC,gBAAR,CAAyBnQ,KAAzB,CAAJ,EAAqC;UAC3BgG,YAD2B,GACClH,KADD,CAC3BkH,YAD2B;UACboK,SADa,GACCtR,KADD,CACbsR,SADa;;UAE7BC,mBACJrK,gBAAgBxK,SAASyO,aAAT,CAAuBjE,aAAa9K,GAApC,EAAyCoC,MAAzC,CADlB;;UAGI2M,iBAAiBoG,gBAAjB,IAAqCD,UAAUtM,IAAV,IAAkB,EAA3D,EAA+D;cACvDhB,cAAN;eACOxF,OAAOgT,iBAAP,EAAP;;;;QAIAtC,QAAQuC,eAAR,CAAwBvQ,KAAxB,CAAJ,EAAoC;UAC1BmG,QAD0B,GACFrH,KADE,CAC1BqH,QAD0B;UAChBiK,UADgB,GACFtR,KADE,CAChBsR,SADgB;;UAE5BI,eACJrK,YAAY3K,SAASyO,aAAT,CAAuB9D,SAASjL,GAAhC,EAAqCoC,MAArC,CADd;;UAGI2M,iBAAiBuG,YAAjB,IAAiCJ,WAAUtM,IAAV,IAAkB,EAAvD,EAA2D;cACnDhB,cAAN;eACOxF,OAAOmT,gBAAP,EAAP;;;;;;;;;;;;;;;WAeGC,WAAT,CAAqB1Q,KAArB,EAA4B1C,MAA5B,EAAoCgM,IAApC,EAA0C;UAClC,aAAN,EAAqB,EAAEtJ,YAAF,EAArB;kBACc,IAAd;;;;;;;;;;;;WAYO2Q,SAAT,CAAmB3Q,KAAnB,EAA0B1C,MAA1B,EAAkCgM,IAAlC,EAAwC;UAChC,WAAN,EAAmB,EAAEtJ,YAAF,EAAnB;kBACc,KAAd;;;;;;;;;;;;WAYO4Q,OAAT,CAAiB5Q,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;UAC9B,SAAN,EAAiB,EAAEtJ,YAAF,EAAjB;;QAEQlB,KAH4B,GAGlBxB,MAHkB,CAG5BwB,KAH4B;;QAI9BiI,WAAWD,iBAAiB9G,KAAjB,CAAjB;QACQmI,IAL4B,GAKHpB,QALG,CAK5BoB,IAL4B;QAKtB7H,QALsB,GAKHyG,QALG,CAKtBzG,QALsB;QAKZwD,IALY,GAKHiD,QALG,CAKZjD,IALY;;;QAOhCqE,QAAQ,UAAZ,EAAwB;aACfiE,cAAP,CAAsB9L,QAAtB;;;QAGE6H,QAAQ,MAAR,IAAkBA,QAAQ,MAA9B,EAAsC;UAChC,CAACrE,IAAL,EAAW,OAAOwF,MAAP;UACH9N,QAF4B,GAEQsD,KAFR,CAE5BtD,QAF4B;UAElBI,SAFkB,GAEQkD,KAFR,CAElBlD,SAFkB;UAEPiV,UAFO,GAEQ/R,KAFR,CAEP+R,UAFO;;UAGhCvT,OAAOuN,MAAP,CAAcgG,UAAd,CAAJ,EAA+B,OAAOvH,MAAP;;UAEzBwH,eAAeD,UAArB;UACME,eAAevV,SAASwV,qBAAT,CAA+BpV,SAA/B,CAArB;UACMqV,OAAOzO,MAAM0O,WAAN,CAAkBpN,IAAlB,EAAwB,EAAEgN,0BAAF,EAAgBC,0BAAhB,EAAxB,EACVvV,QADH;aAEO4Q,cAAP,CAAsB6E,IAAtB;;;;;;;;;;;;;;WAcKE,QAAT,CAAkBnR,KAAlB,EAAyB1C,MAAzB,EAAiCgM,IAAjC,EAAuC;UAC/B,UAAN,EAAkB,EAAEtJ,YAAF,EAAlB;;QAEM5E,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;QACQrB,KAJ6B,GAInBxB,MAJmB,CAI7BwB,KAJ6B;QAK7BtD,QAL6B,GAKhBsD,KALgB,CAK7BtD,QAL6B;;QAM/B4E,SAAShF,OAAOiF,YAAP,EAAf;;;QAGI,CAACD,OAAOgR,UAAZ,EAAwB;aACf5G,IAAP;;;;;QAKExO,QAAQoI,UAAUhE,MAAV,EAAkB9C,MAAlB,CAAZ;;QAEI,CAACtB,KAAL,EAAY;;;;iBAIcA,KArBW;QAqB7B+I,MArB6B,UAqB7BA,MArB6B;QAqBrBC,KArBqB,UAqBrBA,KArBqB;;QAsB/BqM,aAAa7V,SAASiI,OAAT,CAAiBsB,OAAO7J,GAAxB,CAAnB;QACMoW,YAAY9V,SAASiI,OAAT,CAAiBuB,MAAM9J,GAAvB,CAAlB;QACMqW,eAAe/V,SAASgW,gBAAT,CAA0BzM,OAAO7J,GAAjC,CAArB;QACMuW,cAAcjW,SAASgW,gBAAT,CAA0BxM,MAAM9J,GAAhC,CAApB;QACMwW,aAAalW,SAASmR,eAAT,CAAyB3H,MAAM9J,GAA/B,CAAnB;QACMyW,cAAcnW,SAASmR,eAAT,CAAyB5H,OAAO7J,GAAhC,CAApB;;;;;;;;;QAUEyW,eACA,CAACrU,OAAOuN,MAAP,CAAc8G,WAAd,CADD,IAEA5M,OAAOlH,MAAP,IAAiB,CAFjB,IAGA6T,UAHA,IAIApU,OAAOuN,MAAP,CAAc6G,UAAd,CAJA,IAKA1M,MAAMnH,MAAN,IAAgB,CANlB,EAOE;cACQ7B,MAAM4V,QAAN,CAAe5M,MAAM6M,SAAN,CAAgB,CAAhB,CAAf,CAAR;;;;;;QAOAN,gBACA,CAACjU,OAAOuN,MAAP,CAAc0G,YAAd,CADD,IAEAxM,OAAOlH,MAAP,IAAiBwT,WAAWvN,IAAX,CAAgBvF,MAHnC,EAIE;UACMqN,QAAQpQ,SAASmR,eAAT,CAAyB5H,OAAO7J,GAAhC,CAAd;UACMiL,WAAWyF,MAAMxF,WAAN,CAAkBrB,OAAO7J,GAAzB,CAAjB;UACIiL,QAAJ,EAAcnK,QAAQA,MAAM4R,YAAN,CAAmBzH,SAASjL,GAA5B,EAAiC,CAAjC,CAAR;;;QAIduW,eACA,CAACnU,OAAOuN,MAAP,CAAc4G,WAAd,CADD,IAEAzM,MAAMnH,MAAN,IAAgByT,UAAUxN,IAAV,CAAevF,MAHjC,EAIE;UACMqN,SAAQpQ,SAASmR,eAAT,CAAyB3H,MAAM9J,GAA/B,CAAd;UACMiL,YAAWyF,OAAMxF,WAAN,CAAkBpB,MAAM9J,GAAxB,CAAjB;UACIiL,SAAJ,EAAcnK,QAAQA,MAAM6R,WAAN,CAAkB1H,UAASjL,GAA3B,EAAgC,CAAhC,CAAR;;;QAGZU,YAAYJ,SAASsW,eAAT,CAAyB9V,KAAzB,CAAhB;gBACYJ,UAAUmW,YAAV,CAAuB,IAAvB,CAAZ;;;;gBAIYnW,UAAUoW,GAAV,CAAc,OAAd,EAAuBlT,MAAMlD,SAAN,CAAgB0O,KAAvC,CAAZ;;WAEOpO,MAAP,CAAcN,SAAd;;;;;;;;;;SAUK;gCAAA;kBAAA;oBAAA;kBAAA;gBAAA;wBAAA;4BAAA;kBAAA;oBAAA;oBAAA;wBAAA;4BAAA;wBAAA;oBAAA;;GAAP;;;AC/uBF;;;;;;AAMA,IAAMoN,UAAQC,MAAM,cAAN,CAAd;;;;;;;;AAQA,SAASgJ,YAAT,GAAwB;MAClBC,gBAAgB,IAApB;MACIC,mBAAmB,CAAvB;MACIC,cAAc,KAAlB;MACIC,YAAY,KAAhB;MACIC,aAAa,KAAjB;;;;;;;;;;WAUSjJ,aAAT,CAAuBrJ,KAAvB,EAA8B1C,MAA9B,EAAsCgM,IAAtC,EAA4C;QACpCC,cAAc,CAAC,CAACvJ,MAAMqF,WAA5B;QACI/H,OAAOoN,QAAX,EAAqB;;;;;QAKjBnB,eAAegJ,wBAAnB,EAA6C;;YAEvC,eAAN,EAAuB,EAAEvS,YAAF,EAAvB;;;;;;;;;;;;WAYOuK,MAAT,CAAgBvK,KAAhB,EAAuB1C,MAAvB,EAA+BgM,IAA/B,EAAqC;QAC/B+I,SAAJ,EAAe;QACX/U,OAAOoN,QAAX,EAAqB;;QAEb8H,aAJ2B,GAIDxS,KAJC,CAI3BwS,aAJ2B;QAIZrS,MAJY,GAIDH,KAJC,CAIZG,MAJY;;QAK7B/E,SAAS0C,UAAUqC,MAAV,CAAf;;;;;;QAMI+R,kBAAkB9W,OAAOI,QAAP,CAAgB0W,aAAtC,EAAqD;;;;QAIjDM,aAAJ,EAAmB;UACXjX,KAAKkX,SAASxX,WAAT,CAAqBqC,MAArB,CAAX;;;;;UAKIkV,kBAAkBjX,EAAtB,EAA0B;;;;UAItBiX,cAAc9T,YAAd,CAA2B,mBAA3B,CAAJ,EAAqD;;;;;UAK/Cf,OAAO4F,SAASiP,aAAT,EAAwBlV,MAAxB,CAAb;UACI/B,GAAGmX,QAAH,CAAYF,aAAZ,KAA8B7U,IAA9B,IAAsC,CAACL,OAAOuN,MAAP,CAAclN,IAAd,CAA3C,EAAgE;;;YAG5D,QAAN,EAAgB,EAAEqC,YAAF,EAAhB;;;;;;;;;;;;WAYO2S,gBAAT,CAA0B3S,KAA1B,EAAiC1C,MAAjC,EAAyCgM,IAAzC,EAA+C;QACvC0C,IAAImG,gBAAV;;;;;WAKO/O,qBAAP,CAA6B,YAAM;UAC7B+O,mBAAmBnG,CAAvB,EAA0B;oBACZ,KAAd;KAFF;;YAKM,kBAAN,EAA0B,EAAEhM,YAAF,EAA1B;;;;;;;;;;;;WAYOyK,OAAT,CAAiBzK,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;YAC9B,SAAN,EAAiB,EAAEtJ,YAAF,EAAjB;;;;;;;;;;;;WAYO4S,kBAAT,CAA4B5S,KAA5B,EAAmC1C,MAAnC,EAA2CgM,IAA3C,EAAiD;kBACjC,IAAd;;;QAGQxK,KAJuC,GAI7BxB,MAJ6B,CAIvCwB,KAJuC;QAKvClD,SALuC,GAKzBkD,KALyB,CAKvClD,SALuC;;;QAO3C,CAACA,UAAUgF,WAAf,EAA4B;;;;;;;;aAQnB2K,MAAP;;;YAGI,oBAAN,EAA4B,EAAEvL,YAAF,EAA5B;;;;;;;;;;;;WAYOgL,MAAT,CAAgBhL,KAAhB,EAAuB1C,MAAvB,EAA+BgM,IAA/B,EAAqC;QAC7BlO,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;gBACY,IAAZ;WACOiD,qBAAP,CAA6B;aAAOiP,YAAY,KAAnB;KAA7B;;YAEM,QAAN,EAAgB,EAAErS,YAAF,EAAhB;;;;;;;;;;;;WAYOiL,KAAT,CAAejL,KAAf,EAAsB1C,MAAtB,EAA8BgM,IAA9B,EAAoC;QAC9BhM,OAAOoN,QAAX,EAAqB;;QAEftP,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;gBACY,IAAZ;WACOiD,qBAAP,CAA6B;aAAOiP,YAAY,KAAnB;KAA7B;;YAEM,OAAN,EAAe,EAAErS,YAAF,EAAf;;;;;;;;;;;;WAYOwL,SAAT,CAAmBxL,KAAnB,EAA0B1C,MAA1B,EAAkCgM,IAAlC,EAAwC;iBACzB,KAAb;YACM,WAAN,EAAmB,EAAEtJ,YAAF,EAAnB;;;;;;;;;;;;WAYO6S,WAAT,CAAqB7S,KAArB,EAA4B1C,MAA5B,EAAoCgM,IAApC,EAA0C;YAClC,aAAN,EAAqB,EAAEtJ,YAAF,EAArB;;;;;;;;;;;;WAYO8S,UAAT,CAAoB9S,KAApB,EAA2B1C,MAA3B,EAAmCgM,IAAnC,EAAyC;YACjC,YAAN,EAAoB,EAAEtJ,YAAF,EAApB;;;;;;;;;;;;WAYO+S,WAAT,CAAqB/S,KAArB,EAA4B1C,MAA5B,EAAoCgM,IAApC,EAA0C;YAClC,aAAN,EAAqB,EAAEtJ,YAAF,EAArB;;;;;;;;;;;;WAYOgT,UAAT,CAAoBhT,KAApB,EAA2B1C,MAA3B,EAAmCgM,IAAnC,EAAyC;;;;;QAKjC3L,OAAO4F,SAASvD,MAAMG,MAAf,EAAuB7C,MAAvB,CAAb;QACIA,OAAOuN,MAAP,CAAclN,IAAd,CAAJ,EAAyBqC,MAAM8C,cAAN;;;;;;QAMrBD,KAAJ,EAAW;YACHC,cAAN;;;;QAIE,CAACwP,UAAL,EAAiB;mBACF,IAAb;;;;UAII,CAACzP,KAAL,EAAY;cACJwC,WAAN,CAAkB2B,YAAlB,CAA+BiM,UAA/B,GAA4C,MAA5C;;;;YAIE,YAAN,EAAoB,EAAEjT,YAAF,EAApB;;;;;;;;;;;;WAYOyL,WAAT,CAAqBzL,KAArB,EAA4B1C,MAA5B,EAAoCgM,IAApC,EAA0C;iBAC3B,IAAb;YACM,aAAN,EAAqB,EAAEtJ,YAAF,EAArB;;;;;;;;;;;;WAYO8L,MAAT,CAAgB9L,KAAhB,EAAuB1C,MAAvB,EAA+BgM,IAA/B,EAAqC;QAC/BhM,OAAOoN,QAAX,EAAqB;;;UAGf5H,cAAN;;YAEM,QAAN,EAAgB,EAAE9C,YAAF,EAAhB;;;;;;;;;;;;WAYOuM,OAAT,CAAiBvM,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;QAChC+I,SAAJ,EAAe;QACX/U,OAAOoN,QAAX,EAAqB;;QAEfnP,KAAKkX,SAASxX,WAAT,CAAqBqC,MAArB,CAAX;;;QAGMlC,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;oBACgB/E,OAAOI,QAAP,CAAgB0W,aAAhC;;;;;QAKIgB,cAAclT,MAAMG,MAAN,IAAgB5E,EAAlC,EAAsC;SACjCyJ,KAAH;;;;YAII,SAAN,EAAiB,EAAEhF,YAAF,EAAjB;;;;;;;;;;;;WAYOyM,OAAT,CAAiBzM,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;QAChC8I,WAAJ,EAAiB;QACb9U,OAAOwB,KAAP,CAAalD,SAAb,CAAuBuX,SAA3B,EAAsC;YAChC,SAAN,EAAiB,EAAEnT,YAAF,EAAjB;;;;;;;;;;;;WAYO+N,SAAT,CAAmB/N,KAAnB,EAA0B1C,MAA1B,EAAkCgM,IAAlC,EAAwC;QAClChM,OAAOoN,QAAX,EAAqB;;;;;QAKjB0H,WAAJ,EAAiB;UACXpE,QAAQoF,SAAR,CAAkBpT,KAAlB,CAAJ,EAA8BA,MAAM8C,cAAN;;;;;;;QAQ9B,CAACoL,MAAD,KACCF,QAAQqF,MAAR,CAAerT,KAAf,KACCgO,QAAQG,gBAAR,CAAyBnO,KAAzB,CADD,IAECgO,QAAQK,eAAR,CAAwBrO,KAAxB,CAFD,IAGCgO,QAAQO,oBAAR,CAA6BvO,KAA7B,CAHD,IAICgO,QAAQS,mBAAR,CAA4BzO,KAA5B,CAJD,IAKCgO,QAAQW,oBAAR,CAA6B3O,KAA7B,CALD,IAMCgO,QAAQa,mBAAR,CAA4B7O,KAA5B,CAND,IAOCgO,QAAQsF,QAAR,CAAiBtT,KAAjB,CAPD,IAQCgO,QAAQe,MAAR,CAAe/O,KAAf,CARD,IASCgO,QAAQC,YAAR,CAAqBjO,KAArB,CATD,IAUCgO,QAAQuF,oBAAR,CAA6BvT,KAA7B,CAVD,IAWCgO,QAAQiB,MAAR,CAAejP,KAAf,CAZF,CADF,EAcE;YACM8C,cAAN;;;YAGI,WAAN,EAAmB,EAAE9C,YAAF,EAAnB;;;;;;;;;;;;WAYO4Q,OAAT,CAAiB5Q,KAAjB,EAAwB1C,MAAxB,EAAgCgM,IAAhC,EAAsC;QAChChM,OAAOoN,QAAX,EAAqB;;;UAGf5H,cAAN;;YAEM,SAAN,EAAiB,EAAE9C,YAAF,EAAjB;;;;;;;;;;;;WAYOmR,QAAT,CAAkBnR,KAAlB,EAAyB1C,MAAzB,EAAiCgM,IAAjC,EAAuC;QACjC+I,SAAJ,EAAe;QACXD,WAAJ,EAAiB;;QAEb9U,OAAOoN,QAAX,EAAqB;;;QAGftP,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;oBACgB/E,OAAOI,QAAP,CAAgB0W,aAAhC;;YAEM,UAAN,EAAkB,EAAElS,YAAF,EAAlB;;;;;;;;;;SAUK;gCAAA;kBAAA;oBAAA;sCAAA;0CAAA;kBAAA;gBAAA;wBAAA;4BAAA;0BAAA;4BAAA;0BAAA;4BAAA;kBAAA;oBAAA;oBAAA;wBAAA;oBAAA;;GAAP;;;AC3cF;;;;;;;AAOA,SAASwT,SAAT,GAAiC;MAAdC,OAAc,uEAAJ,EAAI;yBACNA,OADM,CACvBC,OADuB;MACvBA,OADuB,oCACb,EADa;;MAEzBC,eAAe1B,cAArB;MACM2B,cAAc1K,aAApB;UACQyK,YAAR,2BAAyBD,OAAzB,IAAkCE,WAAlC;;;ACPF;;;;;;AAMA,IAAM5K,UAAQC,MAAM,cAAN,CAAd;;;;;;;;IAQM4K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAqCkBC,OAAO;;UAGzBA,MAAMrX,KAAN,IAAe,KAAKqX,KAAL,CAAWrX,KAA1B,IACAqX,MAAMxJ,KAAN,IAAe,KAAKwJ,KAAL,CAAWxJ,KAD1B,IAEAwJ,MAAMhQ,IAAN,IAAc,KAAKgQ,KAAL,CAAWhQ,IAFzB,IAGAgQ,MAAMtU,MAAN,IAAgB,KAAKsU,KAAL,CAAWtU,MAJ7B,EAKE;eACO,IAAP;;;;aAIK,KAAP;;;;;;;;;;;6BASO;WACFwJ,KAAL,CAAW,QAAX,EAAqB,IAArB;;mBAEwB,KAAK8K,KAHtB;UAGCnW,IAHD,UAGCA,IAHD;UAGOlB,KAHP,UAGOA,KAHP;;UAIDkC,YAAYE,UAAUlC,SAAV,CAAoB;aAC/BgB,KAAKzC,GAD0B;;OAApB,CAAlB;;aAME;;UAAM,uBAAN,EAAsB,mBAAiByD,SAAvC;aACQoV,WAAL;OAFL;;;;;;;;;;;kCAaY;oBACkC,KAAKD,KADvC;UACJxJ,KADI,WACJA,KADI;UACG3M,IADH,WACGA,IADH;UACSE,MADT,WACSA,MADT;UACiBiG,IADjB,WACiBA,IADjB;UACuBxG,MADvB,WACuBA,MADvB;;UAEN4P,OAAO,KAAK8G,UAAL,EAAb;UACMC,aAAa;2BACE;OADrB;;aAIO3J,MAAM4J,MAAN,CAAa,UAACC,QAAD,EAAWC,IAAX,EAAoB;YAChCN,QAAQ;wBAAA;oBAAA;sBAAA;oBAAA;wBAAA;oBAAA;4BAAA;;SAAd;YAUMtQ,UAAUlG,OAAO+W,GAAP,CAAW,YAAX,EAAyBP,KAAzB,CAAhB;eACOtQ,WAAW2Q,QAAlB;OAZK,EAaJjH,IAbI,CAAP;;;;;;;;;;;iCAsBW;oBACkD,KAAK4G,KADvD;UACHlI,KADG,WACHA,KADG;UACIjO,IADJ,WACIA,IADJ;UACUL,MADV,WACUA,MADV;UACkBkC,MADlB,WACkBA,MADlB;UAC0BsE,IAD1B,WAC0BA,IAD1B;UACgCrH,KADhC,WACgCA,KADhC;UACuCmQ,MADvC,WACuCA,MADvC;;;;;UAKPtP,OAAOkI,KAAP,CAAa,QAAb,EAAuBhG,MAAvB,CAAJ,EAAoC;eAEhC;;YAAM,yBAAsB,GAA5B,EAAgC,qBAAmBA,OAAOsE,IAAP,CAAYvF,MAA/D;;SADF;;;;;;UAWAuF,SAAS,EAAT,IACAtE,OAAO5C,MAAP,KAAkB,OADlB,IAEA4C,OAAOsE,IAAP,KAAgB,EAFhB,IAGAtE,OAAO8U,KAAP,CAAarH,IAAb,OAAwBtP,IAJ1B,EAKE;eAEE;;YAAM,yBAAsB,GAA5B,EAAgC,qBAAmB,CAAnD;kBAAA;;SADF;;;;;;UAWEmG,SAAS,EAAb,EAAiB;eAEb;;YAAM,yBAAsB,GAA5B,EAAgC,qBAAmB,CAAnD;;SADF;;;;;UASIgJ,WAAWlB,MAAMmB,WAAN,EAAjB;UACMO,WAAWxJ,KAAKyJ,MAAL,CAAYzJ,KAAKvF,MAAL,GAAc,CAA1B,CAAjB;UACM6O,aAAazP,SAASmP,QAA5B;UACMO,aAAa5Q,UAAUmQ,OAAO2H,IAAP,GAAc,CAA3C;UACInH,cAAcC,UAAd,IAA4BC,aAAa,IAA7C,EACE,OAAO;;UAAM,0BAAN;YAAA;OAAP;;;aAGK;;UAAM,0BAAN;;OAAP;;;;EAhKekH,MAAMC;;;;;;;;AAAnBZ,KAOGa,YAAY;SACVC,WAAW/I,KAAX,CAAiBgJ,UADP;UAETC,MAAMjY,MAAN,CAAagY,UAFJ;SAGVC,MAAMC,MAAN,CAAaF,UAHH;UAITD,WAAW/H,MAAX,CAAkBgI,UAJT;SAKVD,WAAWrK,KAAX,CAAiBsK,UALP;QAMXD,WAAWhX,IAAX,CAAgBiX,UANL;UAOTC,MAAMC,MAAN,CAAaF,UAPJ;UAQTD,WAAWhX,IAAX,CAAgBiX,UARP;QASXC,MAAMxY,MAAN,CAAauY,UATF;;;;;OAmBnB5L,QAAQ,UAAC+L,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;8BACtBD,OAAN,EAAkB,OAAKjB,KAAL,CAAWnW,IAAX,CAAgBzC,GAAlC,SAAyC,OAAK4Y,KAAL,CAAWrX,KAApD,SAAgEuY,IAAhE;;;;ACvCJ;;;;;;AAMA,IAAMhM,UAAQC,MAAM,YAAN,CAAd;;;;;;;;IAQMgM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BA+EK;;;WACFjM,KAAL,CAAW,QAAX,EAAqB,IAArB;;mBAE6C,KAAK8K,KAH3C;UAGCoB,WAHD,UAGCA,WAHD;UAGc5X,MAHd,UAGcA,MAHd;UAGsBK,IAHtB,UAGsBA,IAHtB;UAG4BsE,KAH5B,UAG4BA,KAH5B;UAICnD,KAJD,GAIWxB,MAJX,CAICwB,KAJD;UAKCtD,QALD,GAKcsD,KALd,CAKCtD,QALD;UAMCN,GAND,GAMSyC,IANT,CAMCzC,GAND;;;UAQDia,OAAOD,YAAYnN,MAAZ,CAAmB,aAAK;YAC3BxH,KAD2B,GACZ6U,CADY,CAC3B7U,KAD2B;YACpBC,GADoB,GACZ4U,CADY,CACpB5U,GADoB;;;;YAI/BD,MAAMrF,GAAN,KAAcA,GAAd,IAAqBsF,IAAItF,GAAJ,KAAYA,GAArC,EAA0C,OAAO,IAAP;;;YAGtCqF,MAAMrF,GAAN,KAAcsF,IAAItF,GAAtB,EAA2B,OAAO,KAAP;;;YAGrBgP,OAAO1O,SAAS6Z,UAAT,CAAoBna,GAApB,CAAb;YACIoa,UAAUC,OAAV,CAAkBrL,IAAlB,EAAwB3J,MAAM2J,IAA9B,MAAwC,CAAC,CAA7C,EAAgD,OAAO,KAAP;;;YAG5CoL,UAAUC,OAAV,CAAkBrL,IAAlB,EAAwB1J,IAAI0J,IAA5B,MAAsC,CAA1C,EAA6C,OAAO,KAAP;;;eAGtC,IAAP;OAjBW,CAAb;;;UAqBM0C,SAASuI,KAAKZ,IAAL,KAAc,CAAd,GAAkB5W,KAAKkP,SAAL,EAAlB,GAAqClP,KAAKkP,SAAL,CAAesI,IAAf,CAApD;UACItX,SAAS,CAAb;;UAEMsW,WAAWvH,OAAOjF,GAAP,CAAW,UAACuF,IAAD,EAAO3N,CAAP,EAAa;YACjCE,QAAQ,OAAK+V,UAAL,CAAgB5I,MAAhB,EAAwBM,IAAxB,EAA8B3N,CAA9B,EAAiC1B,MAAjC,CAAd;kBACUqP,KAAKpJ,IAAL,CAAUvF,MAApB;eACOkB,KAAP;OAHe,CAAjB;;aAOE;;UAAM,YAAUvE,GAAhB,EAAqB,OAAO+G,KAA5B;;OADF;;;;;;;;;;;;;;;EArHeuS,MAAMC;;;;;;;;AAAnBQ,KAOGP,YAAY;SACVC,WAAW/I,KADD;eAEJ6J,eAAeC,IAAf,CAAoBd,UAFhB;UAGTC,MAAMjY,MAAN,CAAagY,UAHJ;QAIXD,WAAWhX,IAAX,CAAgBiX,UAJL;UAKTD,WAAWhX,IAAX,CAAgBiX,UALP;SAMVC,MAAMjY,MANI;AAPfqY,KAsBGU,eAAe;SACb,IADa;;;;;OAWtB3M,QAAQ,UAAC+L,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;QACpBrX,IADoB,GACX,OAAKmW,KADM,CACpBnW,IADoB;QAEpBzC,GAFoB,GAEZyC,IAFY,CAEpBzC,GAFoB;;8BAGtB6Z,OAAN,EAAkB7Z,GAAlB,qBAAmC8Z,IAAnC;;;OAWFY,wBAAwB,qBAAa;QAC3B9B,KAD2B,UAC3BA,KAD2B;;QAE7B9H,IAAI6J,SAAV;QACMC,IAAIhC,KAAV;;;;;;QAMI9H,EAAErO,IAAF,IAAUmY,EAAEnY,IAAhB,EAAsB,OAAO,IAAP;;;;QAIlBqO,EAAExM,MAAF,CAAS5C,MAAT,IAAmB,OAAvB,EAAgC;UACxBmZ,QAAQD,EAAEtW,MAAF,CAAS8U,KAAT,CAAerH,IAAf,EAAd;UACM+I,QAAQhK,EAAExM,MAAF,CAAS8U,KAAT,CAAerH,IAAf,EAAd;UACI6I,EAAEnY,IAAF,IAAUoY,KAAV,IAAmB/J,EAAErO,IAAF,IAAUqY,KAAjC,EAAwC,OAAO,IAAP;;;;QAItC,CAAChK,EAAEkJ,WAAF,CAAce,MAAd,CAAqBH,EAAEZ,WAAvB,CAAL,EAA0C,OAAO,IAAP;;;WAGnC,KAAP;;;OAgEFM,aAAa,UAAC5I,MAAD,EAASM,IAAT,EAAezQ,KAAf,EAAsBoB,MAAtB,EAAiC;kBACJ,OAAKiW,KADD;QACpClI,KADoC,WACpCA,KADoC;QAC7BjO,IAD6B,WAC7BA,IAD6B;QACvB6B,MADuB,WACvBA,MADuB;QACflC,MADe,WACfA,MADe;QAEpCwG,IAFoC,GAEpBoJ,IAFoB,CAEpCpJ,IAFoC;QAE9BwG,KAF8B,GAEpB4C,IAFoB,CAE9B5C,KAF8B;;;WAK1C,oBAAC,IAAD;WACU3M,KAAKzC,GAAb,SAAoBuB,KADtB;aAESmP,KAFT;cAGUtO,MAHV;aAISb,KAJT;aAKS6N,KALT;YAMQ3M,IANR;cAOUE,MAPV;cAQU2B,MARV;cASUoN,MATV;YAUQ9I;MAXV;;;;AC1JJ;;;;;;AAMA,IAAMkF,UAAQC,MAAM,YAAN,CAAd;;;;;;;;IAQMiN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAoCK;UACCpC,KADD,GACW,IADX,CACCA,KADD;UAECK,QAFD,GAE8BL,KAF9B,CAECK,QAFD;UAEWxW,IAFX,GAE8BmW,KAF9B,CAEWnW,IAFX;UAEiB+M,QAFjB,GAE8BoJ,KAF9B,CAEiBpJ,QAFjB;;UAGDyL,MAAMxY,KAAKf,MAAL,IAAe,OAAf,GAAyB,KAAzB,GAAiC,MAA7C;UACMqF,QAAQ;gBACJ,GADI;eAEL,aAFK;iBAGH,MAHG;kBAIF;OAJZ;;UAOMmU,SACJ;WAAA;UAAK,yBAAL,EAAuB,OAAOnU,KAA9B;aACQ+R,UAAL;OAFL;;UAMMrL,UACJ;WAAA;UAAK,iBAAiB+B,WAAW,IAAX,GAAkB,KAAxC;;OADF;;WAIK1B,KAAL,CAAW,QAAX,EAAqB,EAAE8K,YAAF,EAArB;;aAGE;WAAA;;iCAAA;sBAEYnW,KAAKzC,GAFjB;2BAGmBwP,YAAY/M,KAAKf,MAAL,IAAe,OAA3B,GAAqC,IAArC,GAA4C;;mBAEjD,IAAX,GAAkBwZ,MALrB;;OADF;;;;;;;;;;;;;;;;EA3De5B,MAAMC;;;;;;;;AAAnByB,KAOGxB,YAAY;SACVC,WAAW/I,KADD;YAEPiJ,MAAMwB,GAAN,CAAUzB,UAFH;UAGTC,MAAMjY,MAAN,CAAagY,UAHJ;QAIXD,WAAWhX,IAAX,CAAgBiX,UAJL;UAKTD,WAAWhX,IAAX,CAAgBiX,UALP;YAMPC,MAAMyB,IAAN,CAAW1B,UANJ;;;;;OAgBnB5L,QAAQ,UAAC+L,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;QACpBrX,IADoB,GACX,OAAKmW,KADM,CACpBnW,IADoB;QAEpBzC,GAFoB,GAENyC,IAFM,CAEpBzC,GAFoB;QAEfiN,IAFe,GAENxK,IAFM,CAEfwK,IAFe;;QAGtBoO,KAAQrb,GAAR,UAAgBiN,IAAhB,MAAN;8BACM4M,OAAN,OAAkBwB,EAAlB,SAA2BvB,IAA3B;;;OAuDFhB,aAAa,YAAM;iBACsC,OAAKF,KAD3C;QACTlI,KADS,UACTA,KADS;QACFsJ,WADE,UACFA,WADE;QACWvX,IADX,UACWA,IADX;QACiB+M,QADjB,UACiBA,QADjB;QAC2BpN,MAD3B,UAC2BA,MAD3B;;QAEXmC,QAAQ9B,KAAKoI,YAAL,EAAd;WAEE,oBAAC,IAAD;aACSpI,KAAKf,MAAL,IAAe,OAAf,GAAyBe,IAAzB,GAAgCiO,KADzC;mBAEesJ,WAFf;cAGU5X,MAHV;WAIOmC,MAAMvE,GAJb;YAKQuE,KALR;cAMU9B,IANV;gBAOY+M;MARd;;;;ACxGJ;;;;;;;;AAQA,SAAS8L,sBAAT,CAAgC7Y,IAAhC,EAAsCuX,WAAtC,EAAmD;MAC3CuB,oBAAoBC,MAAMC,SAAN,EAA1B;MACMC,sBAAsB,EAA5B;;wBAEsBjZ,IAAtB,EAA4BuX,WAA5B,EAAyC9T,OAAzC,CAAiD,gBAAQ;QACnDwG,KAAKiP,YAAT,EAAuB;;wBAEHC,GAAlB,CAAsBlP,KAAKmP,UAA3B;KAFF,MAGO,IAAInP,KAAKoP,UAAT,EAAqB;;wBAERC,MAAlB,CAAyBrP,KAAKmP,UAA9B;KAFK,MAGA;;0BAEeG,IAApB,CAAyBT,kBAAkBU,MAAlB,EAAzB;;GATJ;;SAaOP,mBAAP;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BF,SAASQ,qBAAT,CAA+BzZ,IAA/B,EAAqCuX,WAArC,EAAkD;MAC5CA,YAAYmC,OAAZ,EAAJ,EAA2B;WAClB1Z,KAAK2W,KAAL,CAAWgD,OAAX,GAAqB3P,GAArB,CAAyB,UAAClI,KAAD,EAAQhD,KAAR;aAAmB;oBAAA;;OAAnB;KAAzB,CAAP;;;;MAOI8a,+BAAe5Z,KAAKzC,GAApB,EAA0B,CAA1B,CAAN;MACIsc,cAAc,CAAlB;;OAEKC,iBAAL,CAAuB,iBAAS;cACpBhY,MAAMvE,GAAhB,IAAuBsc,WAAvB;kBACcA,cAAc,CAA5B;GAFF;;MAKMrY,aAAaxB,KAAK2W,KAAL,CAAWgD,OAAX,EAAnB;;MAEMI,YAAYvY,WAAWwI,GAAX,CAAe,UAAClI,KAAD,EAAQhD,KAAR;WAAmB;kBAAA;kBAAA;aAG3C8a,UAAU9X,MAAMvE,GAAhB;KAHwB;GAAf,CAAlB;;cAMYkG,OAAZ,CAAoB,sBAAc;;;;QAI1BuW,gBAAgBJ,UAAUR,WAAWxW,KAAX,CAAiBrF,GAA3B,CAAtB;QACM0c,uBACJD,kBAAkBzX,SAAlB,GACI,CADJ,GAEI2X,wBAAwB1Y,UAAxB,EAAoCoY,SAApC,EAA+CI,aAA/C,CAHN;;cAKUT,IAAV,CAAe;oBACC,IADD;aAENU,uBAAuB,GAFjB;;KAAf;;;QAOME,cAAc,CAACP,UAAUR,WAAWvW,GAAX,CAAetF,GAAzB,KAAiCsc,WAAlC,IAAiD,GAArE;;cAEUN,IAAV,CAAe;kBACD,IADC;aAENY,WAFM;;KAAf;GAnBF;;SA0BOJ,UAAUK,IAAV,CAAe,UAAChN,CAAD,EAAIiN,CAAJ;WAAWjN,EAAEkN,KAAF,GAAUD,EAAEC,KAAZ,GAAoB,CAApB,GAAwB,CAAC,CAApC;GAAf,CAAP;;;;;;;AAOF,SAASJ,uBAAT,CAAiC1D,QAAjC,EAA2CoD,SAA3C,EAAsDU,KAAtD,EAA6D;;MAErDC,iBAAiB/D,SAASgE,SAAT,CACrB;WAASF,QAAQV,UAAU9X,MAAMvE,GAAhB,CAAjB;GADqB,CAAvB;;MAIIgd,kBAAkB,CAAtB,EAAyB;WAChB,CAAP;;;MAGIE,kBAAkBjE,SAAS+D,iBAAiB,CAA1B,CAAxB;SACOX,UAAUa,gBAAgBld,GAA1B,CAAP;;;AC/GF;;;;;;AAMA,IAAM8N,UAAQC,MAAM,YAAN,CAAd;;;;;;;;IAQM5N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAuCkBwa,WAAW;UACvB/B,KADuB,GACb,IADa,CACvBA,KADuB;UAEvBxW,MAFuB,GAEZwW,KAFY,CAEvBxW,MAFuB;;UAGzB+a,eAAe/a,OAAO+W,GAAP,CACnB,2BADmB,EAEnBP,KAFmB,EAGnB+B,SAHmB,CAArB;UAKM7J,IAAI6J,SAAV;UACMC,IAAIhC,KAAV;;;;;UAKIuE,gBAAgB,IAApB,EAA0B;YACpBA,YAAJ,EAAkB;iBACT,IAAP;;;gBAIAA,iBAAiB,KADnB,EAEE,8LAFF;;;;;UAQErM,EAAEtB,QAAF,IAAcoL,EAAEpL,QAApB,EAA8B,OAAO,IAAP;;;;;;UAM1BsB,EAAErO,IAAF,IAAUmY,EAAEnY,IAAhB,EAAsB,OAAO,IAAP;;;;;;;UAOlBqO,EAAEsM,UAAF,IAAgBxC,EAAEwC,UAAtB,EAAkC,OAAO,IAAP;UAC9BtM,EAAEuM,SAAF,IAAezC,EAAEyC,SAArB,EAAgC,OAAO,IAAP;;;UAG5B,CAACvM,EAAEkJ,WAAF,CAAce,MAAd,CAAqBH,EAAEZ,WAAvB,CAAL,EAA0C,OAAO,IAAP;;;aAGnC,KAAP;;;;;;;;;;;6BASO;;;WACFlM,KAAL,CAAW,QAAX,EAAqB,IAArB;mBASI,KAAK8K,KAVF;UAGLxW,MAHK,UAGLA,MAHK;UAILgb,UAJK,UAILA,UAJK;UAKLC,SALK,UAKLA,SALK;UAML5a,IANK,UAMLA,IANK;UAOLuX,WAPK,UAOLA,WAPK;UAQL1V,MARK,UAQLA,MARK;UASLkL,QATK,UASLA,QATK;UAWC5L,KAXD,GAWWxB,MAXX,CAWCwB,KAXD;UAYClD,SAZD,GAYekD,KAZf,CAYClD,SAZD;;UAaD4c,UAAU7a,KAAK8a,mBAAL,CAAyB7c,SAAzB,EAAoC0c,UAApC,CAAhB;UACMnD,OAAOD,YAAYwD,MAAZ,CAAmB/a,KAAKgb,cAAL,CAAoBrb,MAApB,CAAnB,CAAb;UACMsZ,sBAAsBJ,uBAAuB7Y,IAAvB,EAA6BwX,IAA7B,CAA5B;UACMhB,WAAW,EAAjB;;WAEKG,KAAL,CAAWlT,OAAX,CAAmB,UAAC3B,KAAD,EAAQF,CAAR,EAAc;YACzBqZ,kBAAkB,CAAC,CAACJ,OAAF,IAAaA,QAAQjY,KAAR,IAAiBhB,CAA9B,IAAmCA,IAAIiZ,QAAQhY,GAAvE;;iBAES0W,IAAT,CACE,OAAK2B,UAAL,CAAgBpZ,KAAhB,EAAuBmZ,eAAvB,EAAwChC,oBAAoBrX,CAApB,CAAxC,CADF;OAHF;;;;UAUM0U,aAAa,EAAE,YAAYtW,KAAKzC;;;;OAAtC,CAIA,IAAIyC,KAAKmb,WAAL,EAAJ,EAAwB;YAChBzZ,YAAY1B,KAAKob,gBAAL,EAAlB;YACI1Z,aAAa,KAAjB,EAAwB4U,WAAW+E,GAAX,GAAiB,KAAjB;;;UAGpBlF,QAAQ;aACPnW,KAAKzC,GADE;sBAAA;4BAAA;8BAAA;kBAAA;sBAAA;;OAAd;;UAUMsI,UAAUlG,OAAO+W,GAAP,CAAW,YAAX,eACXP,KADW;8BAAA;;SAAhB;;aAMOxW,OAAOkI,KAAP,CAAa,QAAb,EAAuB7H,IAAvB,IACL;YAAA;aAAemW,KAAf;;OADK,GAGLtQ,OAHF;;;;;;;;;;;;;;EApJegR,MAAMC;;;;;;;;AAAnBpZ,OAOGqZ,YAAY;SACVC,WAAW/I,KADD;eAEJ6J,eAAeC,IAAf,CAAoBd,UAFhB;UAGTC,MAAMjY,MAAN,CAAagY,UAHJ;aAINC,MAAMyB,IAAN,CAAW1B,UAJL;cAKLC,MAAMyB,IAAN,CAAW1B,UALN;QAMXD,WAAWhX,IAAX,CAAgBiX,UANL;UAOTD,WAAWhX,IAAX,CAAgBiX,UAPP;YAQPC,MAAMyB,IAAN,CAAW1B,UARJ;;;;;OAkBnB5L,QAAQ,UAAC+L,OAAD,EAAsB;uCAATC,IAAS;UAAA;;;QACpBrX,IADoB,GACX,OAAKmW,KADM,CACpBnW,IADoB;QAEpBzC,GAFoB,GAENyC,IAFM,CAEpBzC,GAFoB;QAEfiN,IAFe,GAENxK,IAFM,CAEfwK,IAFe;;8BAGtB4M,OAAN,EAAkB7Z,GAAlB,UAA0BiN,IAA1B,eAAsC6M,IAAtC;;;OAwIF6D,aAAa,UAACpZ,KAAD,EAAQ6Y,UAAR,EAAoBpD,WAApB,EAAoC;kBACM,OAAKpB,KADX;QACvClI,KADuC,WACvCA,KADuC;QAChCtO,MADgC,WAChCA,MADgC;QACxBK,IADwB,WACxBA,IADwB;QAClB+M,QADkB,WAClBA,QADkB;QACR6N,SADQ,WACRA,SADQ;;QAEzC9D,YAAYhV,MAAM7C,MAAN,IAAgB,MAAhB,GAAyBqY,IAAzB,GAAgC5Z,MAAlD;;WAGE,oBAAC,SAAD;aACSsC,KAAKf,MAAL,IAAe,OAAf,GAAyBe,IAAzB,GAAgCiO,KADzC;mBAEesJ,WAFf;cAGU5X,MAHV;kBAIcgb,UAJd;iBAKaC,aAAaD,UAL1B;WAMO7Y,MAAMvE,GANb;YAOQuE,KAPR;cAQU9B,IARV;gBASY+M;MAVd;;;;AC/LJ;;;;;;;;AAQA,SAASuO,YAAT,CAAsBjd,KAAtB,EAA2C;MAAdb,GAAc,uEAARC,MAAQ;MACjC2J,MADiC,GACU/I,KADV,CACjC+I,MADiC;MACzBC,KADyB,GACUhJ,KADV,CACzBgJ,KADyB;MAClBkU,aADkB,GACUld,KADV,CAClBkd,UADkB;MACNtY,WADM,GACU5E,KADV,CACN4E,WADM;;MAEnCsE,YAAYxB,aAAaqB,MAAb,EAAqB5J,GAArB,CAAlB;MACMgK,WAAWvE,cAAcsE,SAAd,GAA0BxB,aAAasB,KAAb,EAAoB7J,GAApB,CAA3C;;MAEI,CAAC+J,SAAD,IAAc,CAACC,QAAnB,EAA6B,OAAO,IAAP;;MAEvB7D,IAAInG,IAAIK,QAAJ,CAAa0C,WAAb,EAAV;MACMqC,QAAQ2Y,gBAAa/T,QAAb,GAAwBD,SAAtC;MACM1E,MAAM0Y,gBAAahU,SAAb,GAAyBC,QAArC;IACE/G,QAAF,CAAWmC,MAAM5C,IAAjB,EAAuB4C,MAAM1C,MAA7B;IACEQ,MAAF,CAASmC,IAAI7C,IAAb,EAAmB6C,IAAI3C,MAAvB;SACOyD,CAAP;;;AClBF;;;;;;AAMA,IAAM6X,YAAY,CAAC,MAAD,EAAS,SAAT,EAAoB,QAApB,CAAlB;;;;;;AAMA,IAAMC,YAAYlL,UAAU,CAAC,CAAC9S,OAAOie,SAAP,CAAiBC,SAAjB,CAA2BC,KAA3B,CAAiC,SAAjC,CAA9B;;;;;;;;AAQA,SAASC,mBAAT,CAA6Bje,EAA7B,EAAiCH,MAAjC,EAAyC;MACnCoE,SAASjE,GAAGwC,UAAhB;MACI0b,iBAAJ;;SAEO,CAACA,QAAR,EAAkB;QACZ,CAACja,OAAOzB,UAAZ,EAAwB;;QAElBkE,QAAQ7G,OAAOse,gBAAP,CAAwBla,MAAxB,CAAd;QACQma,SAJQ,GAIM1X,KAJN,CAIR0X,SAJQ;;;QAMZR,UAAUS,QAAV,CAAmBD,SAAnB,CAAJ,EAAmC;iBACtBna,MAAX;;;;aAIOA,OAAOzB,UAAhB;;;;;;;;MAQE,CAAC0b,QAAL,EAAe;WACNre,OAAOI,QAAP,CAAgBM,IAAvB;;;SAGK2d,QAAP;;;;;;;;;AASF,SAASI,iBAAT,CAA2Bje,SAA3B,EAAsC;MAChCwd,SAAJ,EAAe;MACX,CAACxd,UAAUyI,UAAf,EAA2B;;MAErBjJ,SAAS0C,UAAUlC,UAAUyI,UAApB,CAAf;MACMoV,WAAWD,oBAAoB5d,UAAUyI,UAA9B,EAA0CjJ,MAA1C,CAAjB;MACM0e,WACJL,YAAYre,OAAOI,QAAP,CAAgBM,IAA5B,IACA2d,YAAYre,OAAOI,QAAP,CAAgBue,eAF9B;MAGMC,WAAWd,WAAWtd,SAAX,CAAjB;;MAEMI,QAAQJ,UAAUoF,UAAV,CAAqB,CAArB,EAAwBO,UAAxB,EAAd;QACMtF,QAAN,CAAe+d,QAAf;MACIC,aAAaje,MAAM0J,qBAAN,EAAjB;;;;;;;MAOIwU,SAAJ,EAAe;QACTle,MAAMme,SAAN,IAAmBF,WAAWpU,GAAX,IAAkB,CAArC,IAA0CoU,WAAWnU,MAAX,IAAqB,CAAnE,EAAsE;UAChE9J,MAAMyI,WAAN,IAAqB,CAAzB,EAA4B;cACpBpG,MAAN,CAAarC,MAAM0I,YAAnB,EAAiC,CAAjC;OADF,MAEO;cACCtG,QAAN,CAAepC,MAAMsI,cAArB,EAAqCtI,MAAMyI,WAAN,GAAoB,CAAzD;;;mBAGWzI,MAAM0J,qBAAN,EAAb;;UAEIuU,WAAWpU,GAAX,IAAkB,CAAlB,IAAuBoU,WAAWnU,MAAX,IAAqB,CAAhD,EAAmD;YAC7C9J,MAAMoe,cAAN,GAAuB7b,MAA3B,EAAmC;uBACpBvC,MAAMoe,cAAN,GAAuB,CAAvB,CAAb;;;;;;MAMJxU,cAAJ;MACIE,eAAJ;MACIuU,gBAAJ;MACIC,gBAAJ;MACIC,cAAc,CAAlB;MACIC,eAAe,CAAnB;MACIC,mBAAmB,CAAvB;MACIC,mBAAmB,CAAvB;MACIC,qBAAqB,CAAzB;MACIC,wBAAwB,CAA5B;MACIC,sBAAsB,CAA1B;MACIC,uBAAuB,CAA3B;;MAEIhB,QAAJ,EAAc;QACJiB,UADI,GACkD3f,MADlD,CACJ2f,UADI;QACQC,WADR,GACkD5f,MADlD,CACQ4f,WADR;QACqBC,WADrB,GACkD7f,MADlD,CACqB6f,WADrB;QACkCC,WADlC,GACkD9f,MADlD,CACkC8f,WADlC;;YAEJH,UAAR;aACSC,WAAT;cACUC,WAAV;cACUC,WAAV;GALF,MAMO;QACGC,WADH,GACwD1B,QADxD,CACG0B,WADH;QACgBC,YADhB,GACwD3B,QADxD,CACgB2B,YADhB;QAC8BC,SAD9B,GACwD5B,QADxD,CAC8B4B,SAD9B;QACyCC,UADzC,GACwD7B,QADxD,CACyC6B,UADzC;;gCAWDlgB,OAAOse,gBAAP,CAAwBD,QAAxB,CAXC;QAGH8B,cAHG,yBAGHA,cAHG;QAIHC,iBAJG,yBAIHA,iBAJG;QAKHC,eALG,yBAKHA,eALG;QAMHC,gBANG,yBAMHA,gBANG;QAOHC,UAPG,yBAOHA,UAPG;QAQHC,aARG,yBAQHA,aARG;QASHC,WATG,yBASHA,WATG;QAUHC,YAVG,yBAUHA,YAVG;;QAaCC,eAAetC,SAAS/T,qBAAT,EAArB;YACQyV,WAAR;aACSC,YAAT;kBACcW,aAAalW,GAAb,GAAmBnJ,SAAS6e,cAAT,EAAyB,EAAzB,CAAjC;mBACeQ,aAAa7Y,IAAb,GAAoBxG,SAAS+e,eAAT,EAA0B,EAA1B,CAAnC;;uBAGE/e,SAAS6e,cAAT,EAAyB,EAAzB,IAA+B7e,SAAS8e,iBAAT,EAA4B,EAA5B,CADjC;;uBAIE9e,SAAS+e,eAAT,EAA0B,EAA1B,IAAgC/e,SAASgf,gBAAT,EAA2B,EAA3B,CADlC;;yBAGqBhf,SAASif,UAAT,EAAqB,EAArB,CAArB;4BACwBjf,SAASkf,aAAT,EAAwB,EAAxB,CAAxB;0BACsBlf,SAASmf,WAAT,EAAsB,EAAtB,CAAtB;2BACuBnf,SAASof,YAAT,EAAuB,EAAvB,CAAvB;cACUT,SAAV;cACUC,UAAV;;;MAGIU,YAAY/B,WAAWpU,GAAX,GAAiBwU,OAAjB,GAA2BE,WAA7C;MACM0B,aAAahC,WAAW/W,IAAX,GAAkBoX,OAAlB,GAA4BE,YAA/C;;MAEIlV,IAAIgV,OAAR;MACI/U,IAAI8U,OAAR;;MAEI4B,aAAa3B,OAAjB,EAA0B;;QAEpB2B,aAAapB,mBAAjB;GAFF,MAGO,IACLoB,aAAahC,WAAWrU,KAAxB,GAAgC8U,gBAAhC,GACAJ,UAAU1U,KAFL,EAGL;;QAEIqW,aAAavB,gBAAb,GAAgCI,oBAAhC,GAAuDlV,KAA3D;;;MAGEoW,YAAY3B,OAAhB,EAAyB;;QAEnB2B,YAAYrB,kBAAhB;GAFF,MAGO,IACLqB,YAAY/B,WAAWnU,MAAvB,GAAgC2U,gBAAhC,GACAJ,UAAUvU,MAFL,EAGL;;QAGEkW,YACAvB,gBADA,GAEAG,qBAFA,GAGAX,WAAWnU,MAHX,GAIAA,MALF;;;MAQEgU,QAAJ,EAAc;WACLoC,QAAP,CAAgB5W,CAAhB,EAAmBC,CAAnB;GADF,MAEO;aACI8V,SAAT,GAAqB9V,CAArB;aACS+V,UAAT,GAAsBhW,CAAtB;;;;AC3KJ,IAAM6W,iCAAiC,iDAAvC;;;;;;;;AAQA,IAAMnT,UAAQC,MAAM,eAAN,CAAd;;;;;;;;IAQMmT;;;;;;;;;;;;;;uLAqCJC,MAAM;2BACiB;;;;;;;;aASvBC,WAAWvhB,eAAemZ,MAAf,CAAsB,UAACpL,GAAD,EAAMyT,OAAN,EAAkB;UAC7CA,OAAJ,IAAe;eAAS,MAAKC,OAAL,CAAaD,OAAb,EAAsBvc,KAAtB,CAAT;OAAf;aACO8I,GAAP;KAFS,EAGR,EAHQ,SA+DX2T,kBAAkB,YAAM;UACdnf,MADc,GACH,MAAKwW,KADF,CACdxW,MADc;UAEdwB,KAFc,GAEJxB,MAFI,CAEdwB,KAFc;UAGdlD,SAHc,GAGAkD,KAHA,CAGdlD,SAHc;UAIdsd,aAJc,GAICtd,SAJD,CAIdsd,UAJc;;UAKhB9d,SAAS0C,UAAU,MAAK0F,OAAf,CAAf;UACMpD,SAAShF,OAAOiF,YAAP,EAAf;UACQ6R,aAPc,GAOI9W,OAAOI,QAPX,CAOd0W,aAPc;;;;;UAWlB,CAAC9R,MAAL,EAAa;;;;UAILgR,UAfc,GAeahR,MAfb,CAedgR,UAfc;UAeF/M,UAfE,GAeajE,MAfb,CAeFiE,UAfE;;UAgBlBqY,UAAU,KAAd;;;;UAII9gB,UAAUuX,SAAV,IAAuBjB,kBAAkB,MAAK1O,OAAlD,EAA2D;cACpDA,OAAL,CAAagH,IAAb;kBACU,IAAV;;;;;UAKE5O,UAAU+gB,OAAV,IAAqBvL,UAArB,IAAmC,MAAKwL,UAAL,CAAgBvY,UAAhB,CAAvC,EAAoE;wBAClDjE,MAAhB;kBACU,IAAV;;;;;UAKExE,UAAU2c,SAAV,IAAuBrG,kBAAkB,MAAK1O,OAAlD,EAA2D;cACpDA,OAAL,CAAawB,KAAb;kBACU,IAAV;;;;UAIEpJ,UAAU2c,SAAV,IAAuB3c,UAAUihB,KAArC,EAA4C;YACpCC,UAAU,CAAC,CAAC1L,UAAF,IAAgBhR,OAAOY,UAAP,CAAkB,CAAlB,CAAhC;YACMhF,QAAQid,aAAard,SAAb,EAAwBR,MAAxB,CAAd;;YAEI,CAACY,KAAL,EAAY;kBAER,KADF,EAEE,+DAFF;;;;;YAQMsI,cAbkC,GAauBtI,KAbvB,CAalCsI,cAbkC;YAalBG,WAbkB,GAauBzI,KAbvB,CAalByI,WAbkB;YAaLC,YAbK,GAauB1I,KAbvB,CAaL0I,YAbK;YAaSC,SAbT,GAauB3I,KAbvB,CAaS2I,SAbT;;;;;;;YAmBtCmY,OAAJ,EAAa;cAERxY,kBAAkBwY,QAAQxY,cAA1B,IACCG,eAAeqY,QAAQrY,WADxB,IAECC,gBAAgBoY,QAAQpY,YAFzB,IAGCC,aAAamY,QAAQnY,SAHvB,IAICL,kBAAkBwY,QAAQpY,YAA1B,IACCD,eAAeqY,QAAQnY,SADxB,IAECD,gBAAgBoY,QAAQxY,cAFzB,IAGCK,aAAamY,QAAQrY,WARzB,EASE;;;;;;kBAMM,IAAV;cACK4X,GAAL,CAASU,mBAAT,GAA+B,IAA/B;wBACgB3c,MAAhB;;;YAGIA,OAAO4c,gBAAX,EAA6B;;;cAGvB9D,aAAJ,EAAgB;mBACP8D,gBAAP,CACEhhB,MAAM0I,YADR,EAEE1I,MAAM2I,SAFR,EAGE3I,MAAMsI,cAHR,EAIEtI,MAAMyI,WAJR;WADF,MAOO;mBACEuY,gBAAP,CACEhhB,MAAMsI,cADR,EAEEtI,MAAMyI,WAFR,EAGEzI,MAAM0I,YAHR,EAIE1I,MAAM2I,SAJR;;SAXJ,MAkBO;iBACErB,QAAP,CAAgBtH,KAAhB;;;;0BAIgBoE,MAAlB;;;;mBAIW,YAAM;;;cAGX8S,cAAc,MAAK1P,OAAvB,EAAgC;kBACzBA,OAAL,CAAawB,KAAb;;;gBAGGqX,GAAL,CAASU,mBAAT,GAA+B,KAA/B;SAPF;;;UAWEL,OAAJ,EAAa;gBACL,iBAAN,EAAyB,EAAE9gB,oBAAF,EAAawE,cAAb,EAAqB8R,4BAArB,EAAzB;;aAUJ+K,MAAM,mBAAW;YACVzZ,OAAL,GAAeA,OAAf;aAYFoZ,aAAa,kBAAU;;UACbpZ,OADa,UACbA,OADa;;;UAGjBjI,WAAJ;;UAEI;;;YAGE4E,OAAOjB,QAAP,KAAoB,CAAxB,EAA2B;iBAClB,KAAP;;;;;aAKGiB,OAAOjB,QAAP,KAAoB,CAApB,GAAwBiB,OAAOpC,UAA/B,GAA4CoC,MAAjD;OATF,CAUE,OAAO8H,GAAP,EAAY;;;;;YAKRiL,cAAciJ,+BAA+Be,IAA/B,CAAoCjV,IAAI8M,OAAxC,CAAlB,EAAoE;iBAC3D,KAAP;;;cAGI9M,GAAN;;;aAIA1M,GAAG4hB,iBAAH,KACC5hB,OAAOiI,OAAP,IAAkBjI,GAAG0C,OAAH,CAAW,qBAAX,MAAsCuF,OADzD,CADF;aA8FF4Z,0BAA0BC,SAAS,iBAAS;UACtC,MAAKvJ,KAAL,CAAWpJ,QAAf,EAAyB;;UAEnBtP,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;UACQ+R,aAJkC,GAIhB9W,OAAOI,QAJS,CAIlC0W,aAJkC;;UAKtCA,kBAAkB,MAAK1O,OAA3B,EAAoC;;YAE/BsQ,KAAL,CAAW0I,OAAX,CAAmB,UAAnB,EAA+Bxc,KAA/B;KAPwB,EAQvB,GARuB,SA2F1B6Y,aAAa,UAACpZ,KAAD,EAAQ6Y,UAAR,EAAoBpD,WAApB,EAAoC;wBAClB,MAAKpB,KADa;UACvCxW,MADuC,eACvCA,MADuC;UAC/BoN,QAD+B,eAC/BA,QAD+B;UAEvC5L,KAFuC,GAE7BxB,MAF6B,CAEvCwB,KAFuC;UAGvCtD,QAHuC,GAGfsD,KAHe,CAGvCtD,QAHuC;UAG7BI,SAH6B,GAGfkD,KAHe,CAG7BlD,SAH6B;UAIvC2c,SAJuC,GAIzB3c,SAJyB,CAIvC2c,SAJuC;;;aAO7C,oBAACld,MAAD;eACS,IADT;gBAEUiC,MAFV;qBAGe4X,WAHf;oBAIcoD,UAJd;mBAKaC,aAAaD,UAL1B;aAMO7Y,MAAMvE,GANb;cAOQuE,KAPR;gBAQUjE,QARV;kBASYkP;QAVd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCA3ZkB;UACZtP,SAAS0C,UAAU,KAAK0F,OAAf,CAAf;;aAEOhI,QAAP,CAAgB8hB,gBAAhB,CACE,iBADF,EAEE,KAAKF,uBAFP;;;;UAOI7K,wBAAJ,EAA8B;aACvB/O,OAAL,CAAa8Z,gBAAb,CAA8B,aAA9B,EAA6C,KAAKhB,QAAL,CAAcjT,aAA3D;;;WAGGoT,eAAL;;;;;;;;;2CAOqB;UACfrhB,SAAS0C,UAAU,KAAK0F,OAAf,CAAf;;UAEIpI,MAAJ,EAAY;eACHI,QAAP,CAAgB+hB,mBAAhB,CACE,iBADF,EAEE,KAAKH,uBAFP;;;UAME7K,wBAAJ,EAA8B;aACvB/O,OAAL,CAAa+Z,mBAAb,CACE,aADF,EAEE,KAAKjB,QAAL,CAAcjT,aAFhB;;;;;;;;;;yCAWiB;WACdoT,eAAL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA6LMF,SAASvc,OAAO;cAChB,SAAN,EAAiBuc,OAAjB;;;;UAKE,KAAKF,GAAL,CAASU,mBAAT,KACCR,WAAW,UAAX,IAAyBA,WAAW,QAApC,IAAgDA,WAAW,SAD5D,CADF,EAGE;;;;;;;;;UASEA,WAAW,UAAf,EAA2B;YACjBjf,MADiB,GACN,KAAKwW,KADC,CACjBxW,MADiB;YAEjBwB,KAFiB,GAEPxB,MAFO,CAEjBwB,KAFiB;YAGjBlD,SAHiB,GAGHkD,KAHG,CAGjBlD,SAHiB;;YAInBR,SAAS0C,UAAUkC,MAAMG,MAAhB,CAAf;YACMC,SAAShF,OAAOiF,YAAP,EAAf;YACMrE,QAAQoI,UAAUhE,MAAV,EAAkB9C,MAAlB,CAAd;;YAEItB,SAASA,MAAMia,MAAN,CAAara,UAAU4hB,OAAV,EAAb,CAAb,EAAgD;eACzCf,eAAL;;;;;;UAOFF,WAAW,WAAX,IACAA,WAAW,aADX,IAEAA,WAAW,YAFX,IAGAA,WAAW,aAHX,IAIAA,WAAW,YAJX,IAKAA,WAAW,aALX,IAMAA,WAAW,QAPb,EAQE;YACMte,UAAU+B,MAAMG,MAAN,CAAalC,OAAb,CAAqB,qBAArB,CAAhB;;YAEIA,YAAY,KAAKuF,OAArB,EAA8B;;;;;;;UAQ9B+Y,WAAW,eAAX,IACAA,WAAW,QADX,IAEAA,WAAW,kBAFX,IAGAA,WAAW,oBAHX,IAIAA,WAAW,QAJX,IAKAA,WAAW,OALX,IAMAA,WAAW,SANX,IAOAA,WAAW,SAPX,IAQAA,WAAW,WARX,IASAA,WAAW,SATX,IAUAA,WAAW,SAVX,IAWAA,WAAW,UAZb,EAaE;YACI,CAAC,KAAKK,UAAL,CAAgB5c,MAAMG,MAAtB,CAAL,EAAoC;;;;;WAKjC2T,KAAL,CAAW0I,OAAX,CAAmBD,OAAnB,EAA4Bvc,KAA5B;;;;;;;;;;;;;;;;;;;;;;6BA4BO;;;UACC8T,KADD,GACqB,IADrB,CACCA,KADD;UACQwI,QADR,GACqB,IADrB,CACQA,QADR;UAGL/F,EAHK,GAWHzC,KAXG,CAGLyC,EAHK;UAILkH,SAJK,GAWH3J,KAXG,CAIL2J,SAJK;UAKL/S,QALK,GAWHoJ,KAXG,CAKLpJ,QALK;UAMLpN,MANK,GAWHwW,KAXG,CAMLxW,MANK;UAOLogB,QAPK,GAWH5J,KAXG,CAOL4J,QAPK;UAQLC,IARK,GAWH7J,KAXG,CAQL6J,IARK;UASLC,OATK,GAWH9J,KAXG,CASL8J,OATK;UAULC,UAVK,GAWH/J,KAXG,CAUL+J,UAVK;UAYC/e,KAZD,GAYWxB,MAZX,CAYCwB,KAZD;;UAaDgf,YAAYF,OAAlB;UACQpiB,QAdD,GAcsCsD,KAdtC,CAcCtD,QAdD;UAcWI,SAdX,GAcsCkD,KAdtC,CAcWlD,SAdX;UAcsBsZ,WAdtB,GAcsCpW,KAdtC,CAcsBoW,WAdtB;;UAeDsD,UAAUhd,SAASid,mBAAT,CAA6B7c,SAA7B,CAAhB;UACMuZ,OAAO3Z,SAASmd,cAAT,CAAwBrb,MAAxB,EAAgCob,MAAhC,CAAuCxD,WAAvC,CAAb;UACM0B,sBAAsBJ,uBAAuBhb,QAAvB,EAAiC2Z,IAAjC,CAA5B;;UAEMhB,WAAW3Y,SAAS8Y,KAAT,CAAegD,OAAf,GAAyB3P,GAAzB,CAA6B,UAAClI,KAAD,EAAQF,CAAR,EAAc;YACpD+Y,aAAa,CAAC,CAACE,OAAF,IAAaA,QAAQjY,KAAR,IAAiBhB,CAA9B,IAAmCA,IAAIiZ,QAAQhY,GAAlE;;eAEO,OAAKqY,UAAL,CAAgBpZ,KAAhB,EAAuB6Y,UAAvB,EAAmC1B,oBAAoBrX,CAApB,CAAnC,CAAP;OAHe,CAAjB;;UAMM0C;;iBAEK,MAFL;;oBAIQ,UAJR;;kBAMM;SAINyI,WAAW,EAAX,GAAgB,EAAEqT,kBAAkB,2BAApB,EAVhB,EAYDjK,MAAM7R,KAZL,CAAN;;cAeM,QAAN,EAAgB,EAAE6R,YAAF,EAAhB;;aAGE;iBAAA;qBACMwI,QADN;mCAAA;eAGO,KAAKW,GAHZ;sBAIYzhB,SAASN,GAJrB;2BAKmBwP,WAAW,IAAX,GAAkB,IALrC;8CAAA;cAOM6L,EAPN;qBAQakH,SARb;uBASe3J,MAAMkK,WAAN,GAAoB,IAApB,GAA2B,KAT1C;sBAUcH,UAVd;iBAWS5b,KAXT;gBAYQyI,WAAW,IAAX,GAAkBiT,QAAQ,SAZlC;oBAaYD;;;;YAIV,cAAY;;;OAlBhB;;;;;;;;;;;;;EA/akBlJ,MAAMC;;;;;;;;AAAtB2H,QAOG1H,YAAY;eACJG,MAAMyB,IAAN,CAAW1B,UADP;aAENC,MAAMxY,MAFA;UAGTwY,MAAMjY,MAAN,CAAagY,UAHJ;MAIbC,MAAMxY,MAJO;YAKPwY,MAAMyB,IAAN,CAAW1B,UALJ;QAMXC,MAAMxY,MANK;cAOLwY,MAAMyB,IAAN,CAAW1B,UAPN;SAQVC,MAAMjY,MARI;YASPiY,MAAMC,MATC;WAURD,MAAMxY,MAVE;AAPf+f,QA0BGzG,eAAe;SACb,EADa;WAEX,KAFW;;ACnDxB;;;;;;AAMA,IAAMsI,oCACDljB,cADC,IAEJ,UAFI,EAGJ,cAHI,EAIJ,SAJI,EAKJ,cALI,EAMJ,YANI,EAOJ,YAPI,EAQJ,QARI,EAAN;;;;;;;;;AAkBA,SAASmjB,WAAT,GAAmC;MAAdzK,OAAc,uEAAJ,EAAI;MACzB0K,WADyB,GACK1K,OADL,CACzB0K,WADyB;yBACK1K,OADL,CACZC,OADY;MACZA,OADY,oCACF,EADE;;;;;;;;;;;WAYxB0K,YAAT,CAAsBzgB,IAAtB,EAA4BL,MAA5B,EAAoCgM,IAApC,EAA0C;WACjC,EAAP;;;;;;;;;;;;WAYO+U,YAAT,CAAsBvK,KAAtB,EAA6BxW,MAA7B,EAAqCgM,IAArC,EAA2C;WAEvC,oBAAC,OAAD;mBACewK,MAAMkK,WADrB;iBAEalK,MAAM2J,SAFnB;cAGUngB,MAHV;UAIMwW,MAAMyC,EAJZ;eAKW,iBAACgG,OAAD,EAAUvc,KAAV;eAAoB1C,OAAO+W,GAAP,CAAWkI,OAAX,EAAoBvc,KAApB,CAApB;OALX;gBAMY8T,MAAMpJ,QANlB;YAOQoJ,MAAM6J,IAPd;kBAQc7J,MAAM+J,UARpB;aASS/J,MAAM7R,KATf;gBAUY6R,MAAM4J,QAVlB;eAWW5J,MAAM8J;MAZnB;;;;;;;;;;;;WA0BO/E,UAAT,CAAoB/E,KAApB,EAA2BxW,MAA3B,EAAmCgM,IAAnC,EAAyC;QAC/B2K,UAD+B,GACAH,KADA,CAC/BG,UAD+B;QACnBE,QADmB,GACAL,KADA,CACnBK,QADmB;QACTxW,IADS,GACAmW,KADA,CACTnW,IADS;QAE/Bf,MAF+B,GAEpBe,IAFoB,CAE/Bf,MAF+B;;QAGnCA,UAAU,OAAV,IAAqBA,UAAU,QAAnC,EAA6C,OAAO,IAAP;;QAEvCuZ,MAAMvZ,UAAU,OAAV,GAAoB,KAApB,GAA4B,MAAxC;QACMqF,QAAQ,EAAEgB,UAAU,UAAZ,EAAd;WAEE;SAAA;mBAASgR,UAAT,IAAqB,OAAOhS,KAA5B;;KADF;;;;;;;;;MAaIqc,MAAM,EAAZ;MACMC,eAAeN,MAAM/J,MAAN,CAAa,UAACsK,IAAD,EAAOC,IAAP,EAAgB;QAC5CA,QAAQhL,OAAZ,EAAqB+K,KAAKC,IAAL,IAAahL,QAAQgL,IAAR,CAAb;WACdD,IAAP;GAFmB,EAGlB,EAHkB,CAArB;;MAKItH,IAAJ,CACE1D,UAAU;cACE+K,YAAV,2BAA2B7K,OAA3B;GADF,CADF;;MAMIyK,WAAJ,EAAiB;QACXjH,IAAJ,CACEwH,kBAAkB;8BAAA;YAEV,cAACphB,MAAD,EAASK,IAAT;eACJA,KAAKf,MAAL,KAAgB,UAAhB,IACAe,KAAKmG,IAAL,KAAc,EADd,IAEAnG,KAAK2W,KAAL,CAAWC,IAAX,KAAoB,CAFpB,IAGA5W,KAAKghB,QAAL,GAAgBpK,IAAhB,KAAyB,CAJrB;;KAFR,CADF;;;MAYE2C,IAAJ,CAAS;8BAAA;8BAAA;;GAAT;;SAMOoH,GAAP;;;AC1HF;;;;;;AAMA,IAAMtV,UAAQC,MAAM,cAAN,CAAd;;;;;;;;IAQM2V;;;;;;;;;;;;;;2LAqDJC,QAAQ,UAQRxC,MAAM;eACK,KADL;cAEI,IAFJ;gBAGM,CAHN;eAIK;;;;;;aA+EXyC,oBAAoBC,WAClB,YAA0D;cAItD,MAAK1C,GAAL,CAAS2C,QAAT,GAAoB,CAApB,IAAyB,MAAK3C,GAAL,CAAS2C,QAAT,KAAsB,MAAK3C,GAAL,CAAS4C,OAD1D,EAEE,0XAFF;;YAKK5C,GAAL,CAAS2C,QAAT;UACME,QAAQhB,YAAY,MAAKpK,KAAjB,CAAd;;UAEMqL,WAAW,SAAXA,QAAW,SAAU;YACrB,MAAK9C,GAAL,CAAS+C,OAAb,EAAsB;gBACftL,KAAL,CAAWqL,QAAX,CAAoBE,MAApB;SADF,MAEO;gBACAhD,GAAL,CAASgD,MAAT,GAAkBA,MAAlB;;OAJJ;;YAQKC,UAAL,GAAkB,IAAIC,MAAJ,CAChB,EAAE7L,SAAS,CAACwL,KAAD,CAAX,EAAoBC,kBAApB,EADgB,EAEhB,EAAEG,iBAAF,EAAoBE,WAAW,KAA/B,EAFgB,CAAlB;;YAKKF,UAAL,CAAgBjL,GAAhB,CAAoB,aAApB;KAzBgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCAxEA;WACbgI,GAAL,CAAS+C,OAAT,GAAmB,IAAnB;WACK/C,GAAL,CAAS4C,OAAT;;UAEI,KAAKnL,KAAL,CAAW2L,SAAf,EAA0B;aACnBza,KAAL;;;UAGE,KAAKqX,GAAL,CAASgD,MAAb,EAAqB;aACdvL,KAAL,CAAWqL,QAAX,CAAoB,KAAK9C,GAAL,CAASgD,MAA7B;aACKhD,GAAL,CAASgD,MAAT,GAAkB,IAAlB;;;;;;;;;;yCAQiB;WACdhD,GAAL,CAAS4C,OAAT;;UAEI,KAAK5C,GAAL,CAASgD,MAAb,EAAqB;aACdvL,KAAL,CAAWqL,QAAX,CAAoB,KAAK9C,GAAL,CAASgD,MAA7B;aACKhD,GAAL,CAASgD,MAAT,GAAkB,IAAlB;;;;;;;;;;2CAQmB;WAChBhD,GAAL,CAAS+C,OAAT,GAAmB,KAAnB;;;;;;;;;;;6BASO;cACD,QAAN,EAAgB,IAAhB;UACMtL,qBAAa,KAAKA,KAAlB,IAAyBxW,QAAQ;;;QAAvC,CAFO,IAKCoiB,QALD,GAKqD5L,KALrD,CAKC4L,QALD;UAKWvB,WALX,GAKqDrK,KALrD,CAKWqK,WALX;UAKwBzK,OALxB,GAKqDI,KALrD,CAKwBJ,OALxB;UAKiCiM,OALjC,GAKqD7L,KALrD,CAKiC6L,OALjC;UAK0CC,MAL1C,GAKqD9L,KALrD,CAK0C8L,MAL1C;;WAMFd,iBAAL,CAAuBpL,OAAvB,EAAgCkM,MAAhC,EAAwCF,QAAxC,EAAkDC,OAAlD,EAA2DxB,WAA3D;;;UAGQ1K,OATD,GAS8BK,KAT9B,CASCL,OATD;UASU/I,QATV,GAS8BoJ,KAT9B,CASUpJ,QATV;UASoB5L,KATpB,GAS8BgV,KAT9B,CASoBhV,KATpB;;WAUFwgB,UAAL,CAAgBO,WAAhB,CAA4BnV,QAA5B;WACK4U,UAAL,CAAgBQ,QAAhB,CAAyBhhB,KAAzB,EAAgC2U,OAAhC;;;UAGMU,WAAW,KAAKmL,UAAL,CAAgBjL,GAAhB,CAAoB,cAApB,EAAoCP,KAApC,CAAjB;aACOK,QAAP;;;;;;;;;;;;;;;;;;qCA8DsB;;;aACf,oBAAKmL,UAAL,EAAgBS,cAAhB,8BAAP;;;;8BAGe;;;aACR,qBAAKT,UAAL,EAAgBU,OAAhB,+BAAP;;;;gCAGiB;;;aACV,qBAAKV,UAAL,EAAgBW,SAAhB,+BAAP;;;;4BAGa;;;aACN,qBAAKX,UAAL,EAAgB9Z,KAAhB,+BAAP;;;;sCAGuB;;;aAChB,qBAAK8Z,UAAL,EAAgBY,eAAhB,+BAAP;;;;oCAGqB;;;aACd,qBAAKZ,UAAL,EAAgBa,aAAhB,+BAAP;;;;0BAGW;;;aACJ,qBAAKb,UAAL,EAAgBjL,GAAhB,+BAAP;;;;yCAG0B;;;aACnB,qBAAKiL,UAAL,EAAgBc,kBAAhB,+BAAP;;;;;;;;;2BAyBY;;;aACL,qBAAKd,UAAL,EAAgB3d,IAAhB,+BAAP;;;;6BAGc;;;aACP,sBAAK2d,UAAL,EAAgBD,MAAhB,gCAAP;;;;+BAGgB;;;aACT,sBAAKC,UAAL,EAAgBH,QAAhB,gCAAP;;;;sCAGuB;;;aAChB,sBAAKG,UAAL,EAAgBe,eAAhB,gCAAP;;;;uCAGwB;;;aACjB,sBAAKf,UAAL,EAAgBgB,gBAAhB,gCAAP;;;;8BAGe;;;aACR,sBAAKhB,UAAL,EAAgBiB,OAAhB,gCAAP;;;;yCAG0B;;;aACnB,sBAAKjB,UAAL,EAAgBkB,kBAAhB,gCAAP;;;;2CAG4B;;;aACrB,sBAAKlB,UAAL,EAAgBmB,oBAAhB,gCAAP;;;;;;;;;;;2BA/Fe;aACR,KAAKnB,UAAL,CAAgBoB,UAAvB;;;;2BAGa;aACN,KAAKpB,UAAL,CAAgB5U,QAAvB;;;;2BAGU;aACH,KAAK4U,UAAL,CAAgBxgB,KAAvB;;;;2BAuCW;aACJ,KAAKwgB,UAAL,CAAgBhiB,MAAvB;;;;2BAGW;gBAET,KADF,EAEE,0JAFF;;;;2BAMU;gBAER,KADF,EAEE,yJAFF;;;;EA9OiBkX,MAAMC;;;;;;;;AAArBmK,SAOGlK;eACQG,MAAMyB;aACRzB,MAAMyB;aACNzB,MAAMxY;MACbwY,MAAMxY;YACAwY,MAAM8L;WACP9L,MAAMjY;eACFiY,MAAMwB;WACVxB,MAAM+L;YACL/L,MAAMyB;QACVzB,MAAMxY;UACJwY,MAAMjY;cACFiY,MAAMyB;SACXzB,MAAMjY;YACHiY,MAAMC;SACTH,WAAW7V,KAAX,CAAiB8V;GACrB7Z,eAAemZ,MAAf,CAAsB,UAACpL,GAAD,EAAMyT,OAAN,EAAkB;MACrCA,OAAJ,IAAe1H,MAAM8L,IAArB;SACO7X,GAAP;CAFC,EAGA,EAHA;AAvBD8V,SAmCGjJ,eAAe;aACT,KADS;eAEP,IAFO;YAGV,oBAAM,EAHI;WAIX,EAJW;eAKP,EALO;WAMX,EANW;YAOV,KAPU;UAQZ,EARY;cASR,IATQ;;AC/BxB,YAAe;kBAAA;8BAAA;0BAAA;4BAAA;oBAAA;sBAAA;8BAAA;oCAAA;oCAAA;;CAAf;;;;;"}